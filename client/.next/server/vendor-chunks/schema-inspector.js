/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/schema-inspector";
exports.ids = ["vendor-chunks/schema-inspector"];
exports.modules = {

/***/ "(ssr)/./node_modules/schema-inspector/index.js":
/*!************************************************!*\
  !*** ./node_modules/schema-inspector/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/schema-inspector */ \"(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtSUFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wbGF0ZS1yZWFjdC1uZXh0anMtdHMvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9pbmRleC5qcz9jNDE5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvc2NoZW1hLWluc3BlY3RvcicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/schema-inspector/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js":
/*!***************************************************************!*\
  !*** ./node_modules/schema-inspector/lib/schema-inspector.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Disable no-var because we need to support old IE for now.\n/* eslint-disable no-var */\n// Disable space-before-function-paren for compatibility with VS Code default JS formatter.\n/* eslint-disable space-before-function-paren */\n\n/*\n * This module is intended to be executed both on client side and server side.\n * No error should be thrown. (soft error handling)\n */\n\n(function () {\n  var root = {};\n  // Dependencies --------------------------------------------------------------\n  root.async = ( true) ? __webpack_require__(/*! async */ \"(ssr)/./node_modules/async/dist/async.js\") : 0;\n  if (typeof root.async !== 'object') {\n    throw new Error('Module async is required (https://github.com/caolan/async)');\n  }\n  var async = root.async;\n\n  function _extend(origin, add) {\n    if (!add || typeof add !== 'object') {\n      return origin;\n    }\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n  }\n\n  function _merge() {\n    var ret = {};\n    var args = Array.prototype.slice.call(arguments);\n    var keys = null;\n    var i = null;\n\n    args.forEach(function (arg) {\n      if (arg && arg.constructor === Object) {\n        keys = Object.keys(arg);\n        i = keys.length;\n        while (i--) {\n          ret[keys[i]] = arg[keys[i]];\n        }\n      }\n    });\n    return ret;\n  }\n\n  // Customisable class (Base class) -------------------------------------------\n  // Use with operation \"new\" to extend Validation and Sanitization themselves,\n  // not their prototype. In other words, constructor shall be call to extend\n  // those functions, instead of being in their constructor, like this:\n  //   _extend(Validation, new Customisable);\n\n  function Customisable() {\n    this.custom = {};\n\n    this.extend = function (custom) {\n      return _extend(this.custom, custom);\n    };\n\n    this.reset = function () {\n      this.custom = {};\n    };\n\n    this.remove = function (fields) {\n      if (!_typeIs.array(fields)) {\n        fields = [fields];\n      }\n      fields.forEach(function (field) {\n        delete this.custom[field];\n      }, this);\n    };\n  }\n\n  // Inspection class (Base class) ---------------------------------------------\n  // Use to extend Validation and Sanitization prototypes. Inspection\n  // constructor shall be called in derived class constructor.\n\n  function Inspection(schema, custom) {\n    var _stack = ['@'];\n\n    this._schema = schema;\n    this._custom = {};\n    if (custom != null) {\n      for (var key in custom) {\n        if (Object.prototype.hasOwnProperty.call(custom, key)) {\n          this._custom['$' + key] = custom[key];\n        }\n      }\n    }\n\n    this._getDepth = function () {\n      return _stack.length;\n    };\n\n    this._dumpStack = function () {\n      /* eslint-disable no-control-regex */\n      return _stack.map(function (i) { return i.replace(/^\\[/g, '\\u001b\\u001c\\u001d\\u001e'); })\n        .join('.').replace(/\\.\\u001b\\u001c\\u001d\\u001e/g, '[');\n      /* eslint-enable no-control-regex */\n    };\n\n    this._deeperObject = function (name) {\n      _stack.push((/^[a-z$_][a-z0-9$_]*$/i).test(name) ? name : '[\"' + name + '\"]');\n      return this;\n    };\n\n    this._deeperArray = function (i) {\n      _stack.push('[' + i + ']');\n      return this;\n    };\n\n    this._back = function () {\n      _stack.pop();\n      return this;\n    };\n  }\n  // Simple types --------------------------------------------------------------\n  // If the property is not defined or is not in this list:\n  var _typeIs = {\n    function: function (element) {\n      return typeof element === 'function';\n    },\n    string: function (element) {\n      return typeof element === 'string';\n    },\n    number: function (element) {\n      return typeof element === 'number' && !isNaN(element);\n    },\n    integer: function (element) {\n      return typeof element === 'number' && element % 1 === 0;\n    },\n    NaN: function (element) {\n      return typeof element === 'number' && isNaN(element);\n    },\n    boolean: function (element) {\n      return typeof element === 'boolean';\n    },\n    null: function (element) {\n      return element === null;\n    },\n    date: function (element) {\n      return element != null && element instanceof Date;\n    },\n    object: function (element) {\n      return typeof element === 'object' && element != null && element.constructor !== Array;\n    },\n    array: function (element) {\n      return element != null && element.constructor === Array;\n    },\n    any: function () {\n      return true;\n    }\n  };\n\n  function _simpleType(type, candidate) {\n    if (typeof type === 'function') {\n      return candidate instanceof type;\n    }\n    type = type in _typeIs ? type : 'any';\n    return _typeIs[type](candidate);\n  }\n\n  function _realType(candidate) {\n    for (var i in _typeIs) {\n      if (_simpleType(i, candidate)) {\n        if (i !== 'any' && (i !== 'object' || candidate.constructor === Object)) { return i; }\n        return 'an instance of ' + candidate.constructor.name;\n      }\n    }\n  }\n\n  function getIndexes(a, value) {\n    var indexes = [];\n    var i = a.indexOf(value);\n\n    while (i !== -1) {\n      indexes.push(i);\n      i = a.indexOf(value, i + 1);\n    }\n    return indexes;\n  }\n\n  // Available formats ---------------------------------------------------------\n  /* eslint-disable no-useless-escape */\n  // TODO: Study these regex expressions and add more tests so we can consider removing\n  // rule no-useless-escape.\n  var _formats = {\n    void: /^$/,\n    url: /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)?(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i,\n    'date-time': /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?(Z?|(-|\\+)\\d{2}:\\d{2})$/,\n    date: /^\\d{4}-\\d{2}-\\d{2}$/,\n    coolDateTime: /^\\d{4}(-|\\/)\\d{2}(-|\\/)\\d{2}(T| )\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/,\n    time: /^\\d{2}\\:\\d{2}\\:\\d{2}$/,\n    color: /^#([0-9a-f])+$/i,\n    // Very flexible regular expression designed to catch only obvious mistakes\n    // that a user might make that would have a 100% chance of causing email\n    // delivery to the address to fail. The library takes a flexible over\n    // strict approach. Users should use this only for basic front end email\n    // address validation and perform more strict checking using server-side\n    // code after the data has been sent to their server.\n    // Sourced from https://www.regular-expressions.info/email.html, modified\n    // to allow lowercase characters too.\n    email: /^[^@]+@[^.]+\\.[a-zA-Z]+$/,\n    /* eslint-enable prefer-regex-literals */\n    /* eslint-enable quotes */\n    numeric: /^[0-9]+$/,\n    integer: /^\\-?[0-9]+$/,\n    decimal: /^\\-?[0-9]*\\.?[0-9]+$/,\n    alpha: /^[a-z]+$/i,\n    alphaNumeric: /^[a-z0-9]+$/i,\n    alphaDash: /^[a-z0-9_-]+$/i,\n    javascript: /^[a-z_\\$][a-z0-9_\\$]*$/i,\n    upperString: /^[A-Z ]*$/,\n    lowerString: /^[a-z ]*$/,\n    v4uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n  };\n  /* eslint-enable no-useless-escape */\n\n  // Validation ------------------------------------------------------------------\n  var _validationAttribut = {\n    optional: function (schema, candidate) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional === 'true'); // Default is false\n\n      if (opt === true) {\n        return;\n      }\n      if (typeof candidate === 'undefined') {\n        this.report('is missing and not optional', null, 'optional');\n      }\n    },\n    type: function (schema, candidate) {\n      // return because optional function already handle this case\n      if (typeof candidate === 'undefined' || (typeof schema.type !== 'string' && !(schema.type instanceof Array) && typeof schema.type !== 'function')) {\n        return;\n      }\n      var types = _typeIs.array(schema.type) ? schema.type : [schema.type];\n      var typeIsValid = types.some(function (type) {\n        return _simpleType(type, candidate);\n      });\n      if (!typeIsValid) {\n        types = types.map(function (t) { return typeof t === 'function' ? 'an instance of ' + t.name : t; });\n        this.report('must be ' + types.join(' or ') + ', but is ' + _realType(candidate), null, 'type');\n      }\n    },\n    uniqueness: function (schema, candidate) {\n      if (typeof schema.uniqueness === 'string') { schema.uniqueness = (schema.uniqueness === 'true'); }\n      if (typeof schema.uniqueness !== 'boolean' || schema.uniqueness === false || (!_typeIs.array(candidate) && typeof candidate !== 'string')) {\n        return;\n      }\n      var reported = [];\n      for (var i = 0; i < candidate.length; i++) {\n        if (reported.indexOf(candidate[i]) >= 0) {\n          continue;\n        }\n        var indexes = getIndexes(candidate, candidate[i]);\n        if (indexes.length > 1) {\n          reported.push(candidate[i]);\n          this.report('has value [' + candidate[i] + '] more than once at indexes [' + indexes.join(', ') + ']', null, 'uniqueness');\n        }\n      }\n    },\n    pattern: function (schema, candidate) {\n      var self = this;\n      var regexs = schema.pattern;\n      if (typeof candidate !== 'string') {\n        return;\n      }\n      var matches = false;\n      if (!_typeIs.array(regexs)) {\n        regexs = [regexs];\n      }\n      regexs.forEach(function (regex) {\n        if (typeof regex === 'string' && regex in _formats) {\n          regex = _formats[regex];\n        }\n        if (regex instanceof RegExp) {\n          if (regex.test(candidate)) {\n            matches = true;\n          }\n        }\n      });\n      if (!matches) {\n        self.report('must match [' + regexs.join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'pattern');\n      }\n    },\n    validDate: function (schema, candidate) {\n      if (String(schema.validDate) === 'true' && candidate instanceof Date && isNaN(candidate.getTime())) {\n        this.report('must be a valid date', null, 'validDate');\n      }\n    },\n    minLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var minLength = Number(schema.minLength);\n      if (isNaN(minLength)) {\n        return;\n      }\n      if (candidate.length < minLength) {\n        this.report('must be longer than ' + minLength + ' elements, but it has ' + candidate.length, null, 'minLength');\n      }\n    },\n    maxLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var maxLength = Number(schema.maxLength);\n      if (isNaN(maxLength)) {\n        return;\n      }\n      if (candidate.length > maxLength) {\n        this.report('must be shorter than ' + maxLength + ' elements, but it has ' + candidate.length, null, 'maxLength');\n      }\n    },\n    exactLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var exactLength = Number(schema.exactLength);\n      if (isNaN(exactLength)) {\n        return;\n      }\n      if (candidate.length !== exactLength) {\n        this.report('must have exactly ' + exactLength + ' elements, but it have ' + candidate.length, null, 'exactLength');\n      }\n    },\n    lt: function (schema, candidate) {\n      var limit = Number(schema.lt);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate >= limit) {\n        this.report('must be less than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lt');\n      }\n    },\n    lte: function (schema, candidate) {\n      var limit = Number(schema.lte);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate > limit) {\n        this.report('must be less than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lte');\n      }\n    },\n    gt: function (schema, candidate) {\n      var limit = Number(schema.gt);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate <= limit) {\n        this.report('must be greater than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gt');\n      }\n    },\n    gte: function (schema, candidate) {\n      var limit = Number(schema.gte);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate < limit) {\n        this.report('must be greater than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gte');\n      }\n    },\n    eq: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string' && typeof candidate !== 'boolean') {\n        return;\n      }\n      var limit = schema.eq;\n      if (typeof limit !== 'number' && typeof limit !== 'string' && typeof limit !== 'boolean' && !_typeIs.array(limit)) {\n        return;\n      }\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            return;\n          }\n        }\n        this.report('must be equal to [' + limit.map(function (l) {\n          return '\"' + l + '\"';\n        }).join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'eq');\n      } else {\n        if (candidate !== limit) {\n          this.report('must be equal to \"' + limit + '\", but is equal to \"' + candidate + '\"', null, 'eq');\n        }\n      }\n    },\n    ne: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string') {\n        return;\n      }\n      var limit = schema.ne;\n      if (typeof limit !== 'number' && typeof limit !== 'string' && !_typeIs.array(limit)) {\n        return;\n      }\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            this.report('must not be equal to \"' + limit[i] + '\"', null, 'ne');\n            return;\n          }\n        }\n      } else {\n        if (candidate === limit) {\n          this.report('must not be equal to \"' + limit + '\"', null, 'ne');\n        }\n      }\n    },\n    multipleOf: function (schema, candidate) {\n      const divisor = Number(schema.multipleOf);\n      if (typeof candidate !== 'number' || isNaN(divisor)) {\n        return;\n      }\n      if (candidate % divisor !== 0) {\n        this.report(candidate + ' is not divisible by ' + divisor, null, 'multipleOf');\n      }\n    },\n    someKeys: function (schema, candidat) {\n      var _keys = schema.someKeys;\n      if (!_typeIs.object(candidat)) {\n        return;\n      }\n      var valid = _keys.some(function (action) {\n        return (action in candidat);\n      });\n      if (!valid) {\n        this.report('must have at least key ' + _keys.map(function (i) {\n          return '\"' + i + '\"';\n        }).join(' or '), null, 'someKeys');\n      }\n    },\n    strict: function (schema, candidate) {\n      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }\n      if (schema.strict !== true || !_typeIs.object(candidate) || !_typeIs.object(schema.properties)) {\n        return;\n      }\n      var self = this;\n      if (typeof schema.properties['*'] === 'undefined') {\n        var intruder = Object.keys(candidate).filter(function (key) {\n          return (typeof schema.properties[key] === 'undefined');\n        });\n        if (intruder.length > 0) {\n          var msg = 'should not contains ' + (intruder.length > 1 ? 'properties' : 'property') +\n            ' [' + intruder.map(function (i) { return '\"' + i + '\"'; }).join(', ') + ']';\n          self.report(msg, null, 'strict');\n        }\n      }\n    },\n    exec: function (schema, candidate, callback) {\n      var self = this;\n\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, candidate, callback);\n      }\n      (_typeIs.array(schema.exec) ? schema.exec : [schema.exec]).forEach(function (exec) {\n        if (typeof exec === 'function') {\n          exec.call(self, schema, candidate);\n        }\n      });\n    },\n    properties: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, candidate, callback);\n      }\n      if (!(schema.properties instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n      var properties = schema.properties;\n      var i;\n      if (properties['*'] != null) {\n        for (i in candidate) {\n          if (i in properties) {\n            continue;\n          }\n          this._deeperObject(i);\n          this._validate(properties['*'], candidate[i]);\n          this._back();\n        }\n      }\n      for (i in properties) {\n        if (i === '*') {\n          continue;\n        }\n        this._deeperObject(i);\n        this._validate(properties[i], candidate[i]);\n        this._back();\n      }\n    },\n    items: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, candidate, callback);\n      }\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n      var items = schema.items;\n      var i, l;\n      // If provided schema is an array\n      // then call validate for each case\n      // else it is an Object\n      // then call validate for each key\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        for (i = 0, l = items.length; i < l; i++) {\n          this._deeperArray(i);\n          this._validate(items[i], candidate[i]);\n          this._back();\n        }\n      } else {\n        for (var key in candidate) {\n          if (Object.prototype.hasOwnProperty.call(candidate, key)) {\n            this._deeperArray(key);\n            this._validate(items, candidate[key]);\n            this._back();\n          }\n        }\n      }\n    }\n  };\n\n  var _asyncValidationAttribut = {\n    asyncExec: function (schema, candidate, callback) {\n      var self = this;\n      async.eachSeries(_typeIs.array(schema.exec) ? schema.exec : [schema.exec], function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, candidate, done);\n          }\n          exec.call(self, schema, candidate);\n        }\n        async.nextTick(done);\n      }, callback);\n    },\n    asyncProperties: function (schema, candidate, callback) {\n      if (!(schema.properties instanceof Object) || !_typeIs.object(candidate)) {\n        return callback();\n      }\n      var self = this;\n      var properties = schema.properties;\n      async.series([\n        function (next) {\n          if (properties['*'] == null) {\n            return next();\n          }\n          async.eachSeries(Object.keys(candidate), function (i, done) {\n            if (i in properties) {\n              return async.nextTick(done);\n            }\n            self._deeperObject(i);\n            self._asyncValidate(properties['*'], candidate[i], function (err) {\n              self._back();\n              done(err);\n            });\n          }, next);\n        },\n        function (next) {\n          async.eachSeries(Object.keys(properties), function (i, done) {\n            if (i === '*') {\n              return async.nextTick(done);\n            }\n            self._deeperObject(i);\n            self._asyncValidate(properties[i], candidate[i], function (err) {\n              self._back();\n              done(err);\n            });\n          }, next);\n        }\n      ], callback);\n    },\n    asyncItems: function (schema, candidate, callback) {\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return callback();\n      }\n      var self = this;\n      var items = schema.items;\n\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        async.timesSeries(items.length, function (i, done) {\n          self._deeperArray(i);\n          self._asyncValidate(items[i], candidate[i], function (err, res) {\n            self._back();\n            done(err, res);\n          });\n          self._back();\n        }, callback);\n      } else {\n        async.eachSeries(Object.keys(candidate), function (key, done) {\n          self._deeperArray(key);\n          self._asyncValidate(items, candidate[key], function (err, res) {\n            self._back();\n            done(err, res);\n          });\n        }, callback);\n      }\n    }\n  };\n\n  // Validation Class ----------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n  function Validation(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Validation.custom, custom));\n    var _error = [];\n\n    this._basicFields = Object.keys(_validationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message, code, reason) {\n      var newErr = {\n        code: code || this.userCode || null,\n        reason: reason || 'unknown',\n        message: this.userError || message || 'is invalid',\n        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()\n      };\n      _error.push(newErr);\n      return this;\n    };\n\n    this.result = function () {\n      return {\n        error: _error,\n        valid: _error.length === 0,\n        format: function () {\n          if (this.valid === true) {\n            return 'Candidate is valid';\n          }\n          return this.error.map(function (i) {\n            return 'Property ' + i.property + ': ' + i.message;\n          }).join('\\n');\n        }\n      };\n    };\n  }\n\n  _extend(Validation.prototype, _validationAttribut);\n  _extend(Validation.prototype, _asyncValidationAttribut);\n  _extend(Validation, new Customisable());\n\n  Validation.prototype.validate = function (candidate, callback) {\n    this.origin = candidate;\n    if (typeof callback === 'function') {\n      var self = this;\n      return async.nextTick(function () {\n        self._asyncValidate(self._schema, candidate, function (err) {\n          self.origin = null;\n          callback(err, self.result());\n        });\n      });\n    }\n    return this._validate(this._schema, candidate).result();\n  };\n\n  Validation.prototype._validate = function (schema, candidate, callback) {\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        this[i](schema, candidate);\n      }\n    }, this);\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        this._custom[i].call(this, schema, candidate);\n      }\n    }, this);\n    return this;\n  };\n\n  Validation.prototype._asyncValidate = function (schema, candidate, callback) {\n    var self = this;\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n\n    async.series([\n      function (next) {\n        async.eachSeries(Object.keys(_validationAttribut), function (i, done) {\n          async.nextTick(function () {\n            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n              if (self[i].length > 2) {\n                return self[i](schema, candidate, done);\n              }\n              self[i](schema, candidate);\n            }\n            done();\n          });\n        }, next);\n      },\n      function (next) {\n        async.eachSeries(Object.keys(self._custom), function (i, done) {\n          async.nextTick(function () {\n            if (i in schema && typeof self._custom[i] === 'function') {\n              if (self._custom[i].length > 2) {\n                return self._custom[i].call(self, schema, candidate, done);\n              }\n              self._custom[i].call(self, schema, candidate);\n            }\n            done();\n          });\n        }, next);\n      }\n    ], callback);\n  };\n\n  // Sanitization ----------------------------------------------------------------\n  // functions called by _sanitization.type method.\n  var _forceType = {\n    number: function (post, schema) {\n      var n;\n      if (typeof post === 'number') {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') {\n          return schema.def;\n        }\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseFloat(post.replace(/,/g, '.').replace(/ /g, ''));\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (post instanceof Date) {\n        return +post;\n      }\n      return null;\n    },\n    integer: function (post, schema) {\n      var n;\n      if (typeof post === 'number' && post % 1 === 0) {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') {\n          return schema.def;\n        }\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseInt(post.replace(/ /g, ''), 10);\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (typeof post === 'number') {\n        return parseInt(post, 10);\n      } else if (typeof post === 'boolean') {\n        if (post) { return 1; }\n        return 0;\n      } else if (post instanceof Date) {\n        return +post;\n      }\n      return null;\n    },\n    string: function (post, schema) {\n      if (typeof post === 'boolean' || typeof post === 'number' || post instanceof Date) {\n        return post.toString();\n      } else if (_typeIs.array(post)) {\n        // If user authorize array and strings...\n        if (schema.items || schema.properties) {\n          return post;\n        }\n        return post.join(String(schema.joinWith || ','));\n      } else if (post instanceof Object) {\n        // If user authorize objects ans strings...\n        if (schema.items || schema.properties) {\n          return post;\n        }\n        return JSON.stringify(post);\n      } else if (typeof post === 'string' && post.length) {\n        return post;\n      }\n      return null;\n    },\n    date: function (post, schema) {\n      if (post instanceof Date) {\n        return post;\n      } else {\n        var d = new Date(post);\n        if (!isNaN(d.getTime())) { // if valid date\n          return d;\n        }\n      }\n      return null;\n    },\n    boolean: function (post, schema) {\n      if (typeof post === 'undefined') return null;\n      if (typeof post === 'string' && post.toLowerCase() === 'false') return false;\n      return !!post;\n    },\n    object: function (post, schema) {\n      if (typeof post !== 'string' || _typeIs.object(post)) {\n        return post;\n      }\n      try {\n        return JSON.parse(post);\n      } catch (e) {\n        return null;\n      }\n    },\n    array: function (post, schema) {\n      if (_typeIs.array(post)) {\n        return post;\n      }\n      if (typeof post === 'undefined') {\n        return null;\n      }\n      if (typeof post === 'string') {\n        if (post.substring(0, 1) === '[' && post.slice(-1) === ']') {\n          try {\n            return JSON.parse(post);\n          } catch (e) {\n            return null;\n          }\n        }\n        return post.split(String(schema.splitWith || ','));\n      }\n      if (!_typeIs.array(post)) {\n        return [post];\n      }\n      return null;\n    }\n  };\n\n  var _applyRules = {\n    upper: function (post) {\n      return post.toUpperCase();\n    },\n    lower: function (post) {\n      return post.toLowerCase();\n    },\n    title: function (post) {\n      // Fix by seb (replace \\w\\S* by \\S* => exemple : coucou ça va)\n      return post.replace(/\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n      });\n    },\n    capitalize: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1).toLowerCase();\n    },\n    ucfirst: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1);\n    },\n    trim: function (post) {\n      return post.trim();\n    }\n  };\n\n  // Every function return the future value of each property. Therefore you\n  // have to return post even if you do not change its value\n  var _sanitizationAttribut = {\n    strict: function (schema, post) {\n      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }\n      if (schema.strict !== true) {\n        return post;\n      }\n      if (!_typeIs.object(schema.properties)) {\n        return post;\n      }\n      if (!_typeIs.object(post)) {\n        return post;\n      }\n      Object.keys(post).forEach(function (key) {\n        if (!(key in schema.properties)) {\n          delete post[key];\n        }\n      });\n      return post;\n    },\n    optional: function (schema, post) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional !== 'false'); // Default: true\n      if (opt === true) {\n        return post;\n      }\n      if (typeof post !== 'undefined') {\n        return post;\n      }\n      this.report();\n      if (schema.def === Date) {\n        return new Date();\n      }\n      return schema.def;\n    },\n    type: function (schema, post) {\n      // if (_typeIs['object'](post) || _typeIs.array(post)) {\n      //   return post;\n      // }\n      if (typeof schema.type !== 'string' || typeof _forceType[schema.type] !== 'function') {\n        return post;\n      }\n      var n;\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : true;\n      if (typeof _forceType[schema.type] === 'function') {\n        n = _forceType[schema.type](post, schema);\n        if ((n === null && !opt) || (!n && isNaN(n)) || (n === null && schema.type === 'string')) {\n          n = schema.def;\n        }\n      } else if (!opt) {\n        n = schema.def;\n      }\n      if ((n != null || (typeof schema.def !== 'undefined' && schema.def === n)) && n !== post) {\n        this.report();\n        return n;\n      }\n      return post;\n    },\n    rules: function (schema, post) {\n      var rules = schema.rules;\n      if (typeof post !== 'string' || (typeof rules !== 'string' && !_typeIs.array(rules))) {\n        return post;\n      }\n      var modified = false;\n      (_typeIs.array(rules) ? rules : [rules]).forEach(function (rule) {\n        if (typeof _applyRules[rule] === 'function') {\n          post = _applyRules[rule](post);\n          modified = true;\n        }\n      });\n      if (modified) {\n        this.report();\n      }\n      return post;\n    },\n    min: function (schema, post) {\n      var postTest = Number(post);\n      if (isNaN(postTest)) {\n        return post;\n      }\n      var min = Number(schema.min);\n      if (isNaN(min)) {\n        return post;\n      }\n      if (postTest < min) {\n        this.report();\n        return min;\n      }\n      return post;\n    },\n    max: function (schema, post) {\n      var postTest = Number(post);\n      if (isNaN(postTest)) {\n        return post;\n      }\n      var max = Number(schema.max);\n      if (isNaN(max)) {\n        return post;\n      }\n      if (postTest > max) {\n        this.report();\n        return max;\n      }\n      return post;\n    },\n    minLength: function (schema, post) {\n      var limit = Number(schema.minLength);\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n      var str = '';\n      var gap = limit - post.length;\n      if (gap > 0) {\n        for (var i = 0; i < gap; i++) {\n          str += '-';\n        }\n        this.report();\n        return post + str;\n      }\n      return post;\n    },\n    maxLength: function (schema, post) {\n      var limit = Number(schema.maxLength);\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n      if (post.length > limit) {\n        this.report();\n        return post.slice(0, limit);\n      }\n      return post;\n    },\n    properties: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, post, callback);\n      }\n      if (!post || typeof post !== 'object') {\n        return post;\n      }\n      var properties = schema.properties;\n      var tmp;\n      var i;\n      if (typeof properties['*'] !== 'undefined') {\n        for (i in post) {\n          if (i in properties) {\n            continue;\n          }\n          this._deeperObject(i);\n          tmp = this._sanitize(properties['*'], post[i]);\n          if (typeof tmp !== 'undefined' || 'exec' in properties['*']) {\n            post[i] = tmp;\n          }\n          this._back();\n        }\n      }\n      for (i in properties) {\n        if (i !== '*') {\n          this._deeperObject(i);\n          tmp = this._sanitize(properties[i], post[i]);\n          if (typeof tmp !== 'undefined' || 'exec' in properties[i]) {\n            post[i] = tmp;\n          }\n          this._back();\n        }\n      }\n      return post;\n    },\n    items: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, post, callback);\n      }\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return post;\n      }\n      var i;\n      if (_typeIs.array(schema.items) && _typeIs.array(post)) {\n        var minLength = schema.items.length < post.length ? schema.items.length : post.length;\n        for (i = 0; i < minLength; i++) {\n          this._deeperArray(i);\n          post[i] = this._sanitize(schema.items[i], post[i]);\n          this._back();\n        }\n      } else {\n        for (i in post) {\n          if (Object.prototype.hasOwnProperty.call(post, i)) {\n            this._deeperArray(i);\n            post[i] = this._sanitize(schema.items, post[i]);\n            this._back();\n          }\n        }\n      }\n      return post;\n    },\n    exec: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, post, callback);\n      }\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n\n      execs.forEach(function (exec) {\n        if (typeof exec === 'function') {\n          post = exec.call(this, schema, post);\n        }\n      }, this);\n      return post;\n    }\n  };\n\n  var _asyncSanitizationAttribut = {\n    asyncExec: function (schema, post, callback) {\n      var self = this;\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n\n      async.eachSeries(execs, function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, post, function (err, res) {\n              if (err) {\n                return done(err);\n              }\n              post = res;\n              done();\n            });\n          }\n          post = exec.call(self, schema, post);\n        }\n        done();\n      }, function (err) {\n        callback(err, post);\n      });\n    },\n    asyncProperties: function (schema, post, callback) {\n      if (!post || typeof post !== 'object') {\n        return callback(null, post);\n      }\n      var self = this;\n      var properties = schema.properties;\n\n      async.series([\n        function (next) {\n          if (properties['*'] == null) {\n            return next();\n          }\n          var globing = properties['*'];\n          async.eachSeries(Object.keys(post), function (i, next) {\n            if (i in properties) {\n              return next();\n            }\n            self._deeperObject(i);\n            self._asyncSanitize(globing, post[i], function (err, res) {\n              if (err) { /* Error can safely be ignored here */ }\n              if (typeof res !== 'undefined') {\n                post[i] = res;\n              }\n              self._back();\n              next();\n            });\n          }, next);\n        },\n        function (next) {\n          async.eachSeries(Object.keys(properties), function (i, next) {\n            if (i === '*') {\n              return next();\n            }\n            self._deeperObject(i);\n            self._asyncSanitize(properties[i], post[i], function (err, res) {\n              if (err) {\n                return next(err);\n              }\n              if (typeof res !== 'undefined') {\n                post[i] = res;\n              }\n              self._back();\n              next();\n            });\n          }, next);\n        }\n      ], function (err) {\n        return callback(err, post);\n      });\n    },\n    asyncItems: function (schema, post, callback) {\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return callback(null, post);\n      }\n      var self = this;\n      var items = schema.items;\n      if (_typeIs.array(items) && _typeIs.array(post)) {\n        var minLength = items.length < post.length ? items.length : post.length;\n        async.timesSeries(minLength, function (i, next) {\n          self._deeperArray(i);\n          self._asyncSanitize(items[i], post[i], function (err, res) {\n            if (err) {\n              return next(err);\n            }\n            post[i] = res;\n            self._back();\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      } else {\n        async.eachSeries(Object.keys(post), function (key, next) {\n          self._deeperArray(key);\n          self._asyncSanitize(items, post[key], function (err, res) {\n            if (err) {\n              return next();\n            }\n            post[key] = res;\n            self._back();\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      }\n      return post;\n    }\n  };\n\n  // Sanitization Class --------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n  function Sanitization(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Sanitization.custom, custom));\n    var _reporting = [];\n\n    this._basicFields = Object.keys(_sanitizationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message) {\n      var newNot = {\n        message: message || 'was sanitized',\n        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()\n      };\n      if (!_reporting.some(function (e) { return e.property === newNot.property; })) {\n        _reporting.push(newNot);\n      }\n    };\n\n    this.result = function (data) {\n      // For old IE.\n      /* eslint-disable object-shorthand */\n      return {\n        data: data,\n        reporting: _reporting,\n        format: function () {\n          return this.reporting.map(function (i) {\n            return 'Property ' + i.property + ' ' + i.message;\n          }).join('\\n');\n        }\n      };\n      /* eslint-enable object-shorthand */\n    };\n  }\n\n  _extend(Sanitization.prototype, _sanitizationAttribut);\n  _extend(Sanitization.prototype, _asyncSanitizationAttribut);\n  _extend(Sanitization, new Customisable());\n\n  Sanitization.prototype.sanitize = function (post, callback) {\n    this.origin = post;\n    if (typeof callback === 'function') {\n      var self = this;\n      return this._asyncSanitize(this._schema, post, function (err, data) {\n        self.origin = null;\n        callback(err, self.result(data));\n      });\n    }\n    var data = this._sanitize(this._schema, post);\n    this.origin = null;\n    return this.result(data);\n  };\n\n  Sanitization.prototype._sanitize = function (schema, post) {\n    this.userAlias = schema.alias || null;\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        post = this[i](schema, post);\n      }\n    }, this);\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        post = this._custom[i].call(this, schema, post);\n      }\n    }, this);\n    return post;\n  };\n\n  Sanitization.prototype._asyncSanitize = function (schema, post, callback) {\n    var self = this;\n    this.userAlias = schema.alias || null;\n\n    async.waterfall([\n      function (next) {\n        async.reduce(self._basicFields, post, function (value, i, next) {\n          async.nextTick(function () {\n            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n              if (self[i].length > 2) {\n                return self[i](schema, value, next);\n              }\n              value = self[i](schema, value);\n            }\n            next(null, value);\n          });\n        }, next);\n      },\n      function (inter, next) {\n        async.reduce(self._customFields, inter, function (value, i, next) {\n          async.nextTick(function () {\n            if (i in schema && typeof self._custom[i] === 'function') {\n              if (self._custom[i].length > 2) {\n                return self._custom[i].call(self, schema, value, next);\n              }\n              value = self._custom[i].call(self, schema, value);\n            }\n            next(null, value);\n          });\n        }, next);\n      }\n    ], callback);\n  };\n\n  // ---------------------------------------------------------------------------\n\n  var INT_MIN = -2147483648;\n  var INT_MAX = 2147483647;\n\n  var _rand = {\n    int: function (min, max) {\n      return min + (0 | Math.random() * (max - min + 1));\n    },\n    float: function (min, max) {\n      return (Math.random() * (max - min) + min);\n    },\n    bool: function () {\n      return (Math.random() > 0.5);\n    },\n    char: function (min, max) {\n      return String.fromCharCode(this.int(min, max));\n    },\n    fromList: function (list) {\n      return list[this.int(0, list.length - 1)];\n    }\n  };\n\n  var _formatSample = {\n    'date-time': function () {\n      return new Date().toISOString();\n    },\n    date: function () {\n      return new Date().toISOString().replace(/T.*$/, '');\n    },\n    time: function () {\n      return new Date().toLocaleTimeString({}, { hour12: false });\n    },\n    color: function (min, max) {\n      var s = '#';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('0123456789abcdefABCDEF');\n      }\n      return s;\n    },\n    numeric: function () {\n      return '' + _rand.int(0, INT_MAX);\n    },\n    integer: function () {\n      if (_rand.bool() === true) {\n        return '-' + this.numeric();\n      }\n      return this.numeric();\n    },\n    decimal: function () {\n      return this.integer() + '.' + this.numeric();\n    },\n    alpha: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');\n      }\n      return s;\n    },\n    alphaNumeric: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');\n      }\n      return s;\n    },\n    alphaDash: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-');\n      }\n      return s;\n    },\n    javascript: function (min, max) {\n      var s = _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$');\n      for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {\n        s += _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$');\n      }\n      return s;\n    }\n  };\n\n  function _getLimits(schema) {\n    var min = INT_MIN;\n    var max = INT_MAX;\n\n    if (schema.gte != null) {\n      min = schema.gte;\n    } else if (schema.gt != null) {\n      min = schema.gt + 1;\n    }\n    if (schema.lte != null) {\n      max = schema.lte;\n    } else if (schema.lt != null) {\n      max = schema.lt - 1;\n    }\n    // For old IE.\n    /* eslint-disable object-shorthand */\n    return { min: min, max: max };\n    /* eslint-enable object-shorthand */\n  }\n\n  var _typeGenerator = {\n    string: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var s = '';\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 32;\n      if (typeof schema.pattern === 'string' && typeof _formatSample[schema.pattern] === 'function') {\n        return _formatSample[schema.pattern](minLength, maxLength);\n      }\n\n      var l = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n      for (var i = 0; i < l; i++) {\n        s += _rand.char(32, 126);\n      }\n      return s;\n    },\n    number: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var limit = _getLimits(schema);\n      var n = _rand.float(limit.min, limit.max);\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.float(limit.min, limit.max);\n        }\n      }\n      return n;\n    },\n    integer: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var limit = _getLimits(schema);\n      var n = _rand.int(limit.min, limit.max);\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.int(limit.min, limit.max);\n        }\n      }\n      return n;\n    },\n    boolean: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      return _rand.bool();\n    },\n    null: function (schema) {\n      return null;\n    },\n    date: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      return new Date();\n    },\n    object: function (schema) {\n      var o = {};\n      var prop = schema.properties || {};\n\n      for (var key in prop) {\n        if (Object.prototype.hasOwnProperty.call(prop, key)) {\n          if (prop[key].optional === true && _rand.bool() === true) {\n            continue;\n          }\n          if (key !== '*') {\n            o[key] = this.generate(prop[key]);\n          } else {\n            var rk = '__random_key_';\n            var randomKey = rk + 0;\n            var n = _rand.int(1, 9);\n            for (var i = 1; i <= n; i++) {\n              if (!(randomKey in prop)) {\n                o[randomKey] = this.generate(prop[key]);\n              }\n              randomKey = rk + i;\n            }\n          }\n        }\n      }\n      return o;\n    },\n    array: function (schema) {\n      var self = this;\n      var items = schema.items || {};\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 16;\n      var type;\n      var candidate;\n      var size;\n      var i;\n\n      if (_typeIs.array(items)) {\n        size = items.length;\n        if (schema.exactLength != null) {\n          size = schema.exactLength;\n        } else if (size < minLength) {\n          size = minLength;\n        } else if (size > maxLength) {\n          size = maxLength;\n        }\n        candidate = new Array(size);\n        type = null;\n        for (i = 0; i < size; i++) {\n          type = items[i].type || 'any';\n          if (_typeIs.array(type)) {\n            type = type[_rand.int(0, type.length - 1)];\n          }\n          candidate[i] = self[type](items[i]);\n        }\n      } else {\n        size = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n        candidate = new Array(size);\n        type = items.type || 'any';\n        if (_typeIs.array(type)) {\n          type = type[_rand.int(0, type.length - 1)];\n        }\n        for (i = 0; i < size; i++) {\n          candidate[i] = self[type](items);\n        }\n      }\n      return candidate;\n    },\n    any: function (schema) {\n      var fields = Object.keys(_typeGenerator);\n      var i = fields[_rand.int(0, fields.length - 2)];\n      return this[i](schema);\n    }\n  };\n\n  // CandidateGenerator Class (Singleton) --------------------------------------\n  function CandidateGenerator() {\n    // Maybe extends Inspection class too ?\n  }\n\n  _extend(CandidateGenerator.prototype, _typeGenerator);\n\n  var _instance = null;\n  CandidateGenerator.instance = function () {\n    if (!(_instance instanceof CandidateGenerator)) {\n      _instance = new CandidateGenerator();\n    }\n    return _instance;\n  };\n\n  CandidateGenerator.prototype.generate = function (schema) {\n    var type = schema.type || 'any';\n    if (_typeIs.array(type)) {\n      type = type[_rand.int(0, type.length - 1)];\n    }\n    return this[type](schema);\n  };\n\n  // Exports ---------------------------------------------------------------------\n  var SchemaInspector = {};\n\n  // if server-side (node.js) else client-side\n  if ( true && module.exports) {\n    module.exports = SchemaInspector;\n  } else {\n    window.SchemaInspector = SchemaInspector;\n  }\n\n  SchemaInspector.newSanitization = function (schema, custom) {\n    return new Sanitization(schema, custom);\n  };\n\n  SchemaInspector.newValidation = function (schema, custom) {\n    return new Validation(schema, custom);\n  };\n\n  SchemaInspector.Validation = Validation;\n  SchemaInspector.Sanitization = Sanitization;\n\n  SchemaInspector.sanitize = function (schema, post, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n    return new Sanitization(schema, custom).sanitize(post, callback);\n  };\n\n  SchemaInspector.validate = function (schema, candidate, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n    return new Validation(schema, custom).validate(candidate, callback);\n  };\n\n  SchemaInspector.generate = function (schema, n) {\n    if (typeof n === 'number') {\n      var r = new Array(n);\n      for (var i = 0; i < n; i++) {\n        r[i] = CandidateGenerator.instance().generate(schema);\n      }\n      return r;\n    }\n    return CandidateGenerator.instance().generate(schema);\n  };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9saWIvc2NoZW1hLWluc3BlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBNkIsSUFBSSxtQkFBTyxDQUFDLHVEQUFPLElBQUksQ0FBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qyx1REFBdUQ7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxFQUFFLGtCQUFrQixrckJBQWtyQixFQUFFLGtCQUFrQixvRkFBb0YsRUFBRSxrQkFBa0IsMkZBQTJGLEVBQUUsa0JBQWtCLDhHQUE4RyxFQUFFLGtCQUFrQjtBQUMxcEMsc0JBQXNCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLElBQUksRUFBRTtBQUNyRixlQUFlLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM3Qix1QkFBdUIsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUM3RSxlQUFlLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUc7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUNBQXlDLGtFQUFrRTtBQUMzRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0NBQXdDO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkMsSUFBSSxlQUFlO0FBQ2hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBNkI7QUFDbkM7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLXJlYWN0LW5leHRqcy10cy8uL25vZGVfbW9kdWxlcy9zY2hlbWEtaW5zcGVjdG9yL2xpYi9zY2hlbWEtaW5zcGVjdG9yLmpzPzc4MjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGlzYWJsZSBuby12YXIgYmVjYXVzZSB3ZSBuZWVkIHRvIHN1cHBvcnQgb2xkIElFIGZvciBub3cuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cbi8vIERpc2FibGUgc3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuIGZvciBjb21wYXRpYmlsaXR5IHdpdGggVlMgQ29kZSBkZWZhdWx0IEpTIGZvcm1hdHRlci5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuXG4vKlxuICogVGhpcyBtb2R1bGUgaXMgaW50ZW5kZWQgdG8gYmUgZXhlY3V0ZWQgYm90aCBvbiBjbGllbnQgc2lkZSBhbmQgc2VydmVyIHNpZGUuXG4gKiBObyBlcnJvciBzaG91bGQgYmUgdGhyb3duLiAoc29mdCBlcnJvciBoYW5kbGluZylcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgcm9vdCA9IHt9O1xuICAvLyBEZXBlbmRlbmNpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcm9vdC5hc3luYyA9ICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykgPyByZXF1aXJlKCdhc3luYycpIDogd2luZG93LmFzeW5jO1xuICBpZiAodHlwZW9mIHJvb3QuYXN5bmMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb2R1bGUgYXN5bmMgaXMgcmVxdWlyZWQgKGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmMpJyk7XG4gIH1cbiAgdmFyIGFzeW5jID0gcm9vdC5hc3luYztcblxuICBmdW5jdGlvbiBfZXh0ZW5kKG9yaWdpbiwgYWRkKSB7XG4gICAgaWYgKCFhZGQgfHwgdHlwZW9mIGFkZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdpbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9tZXJnZSgpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBrZXlzID0gbnVsbDtcbiAgICB2YXIgaSA9IG51bGw7XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgaWYgKGFyZyAmJiBhcmcuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoYXJnKTtcbiAgICAgICAgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgcmV0W2tleXNbaV1dID0gYXJnW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIEN1c3RvbWlzYWJsZSBjbGFzcyAoQmFzZSBjbGFzcykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBVc2Ugd2l0aCBvcGVyYXRpb24gXCJuZXdcIiB0byBleHRlbmQgVmFsaWRhdGlvbiBhbmQgU2FuaXRpemF0aW9uIHRoZW1zZWx2ZXMsXG4gIC8vIG5vdCB0aGVpciBwcm90b3R5cGUuIEluIG90aGVyIHdvcmRzLCBjb25zdHJ1Y3RvciBzaGFsbCBiZSBjYWxsIHRvIGV4dGVuZFxuICAvLyB0aG9zZSBmdW5jdGlvbnMsIGluc3RlYWQgb2YgYmVpbmcgaW4gdGhlaXIgY29uc3RydWN0b3IsIGxpa2UgdGhpczpcbiAgLy8gICBfZXh0ZW5kKFZhbGlkYXRpb24sIG5ldyBDdXN0b21pc2FibGUpO1xuXG4gIGZ1bmN0aW9uIEN1c3RvbWlzYWJsZSgpIHtcbiAgICB0aGlzLmN1c3RvbSA9IHt9O1xuXG4gICAgdGhpcy5leHRlbmQgPSBmdW5jdGlvbiAoY3VzdG9tKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZCh0aGlzLmN1c3RvbSwgY3VzdG9tKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY3VzdG9tID0ge307XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKGZpZWxkcykge1xuICAgICAgaWYgKCFfdHlwZUlzLmFycmF5KGZpZWxkcykpIHtcbiAgICAgICAgZmllbGRzID0gW2ZpZWxkc107XG4gICAgICB9XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY3VzdG9tW2ZpZWxkXTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gIH1cblxuICAvLyBJbnNwZWN0aW9uIGNsYXNzIChCYXNlIGNsYXNzKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVXNlIHRvIGV4dGVuZCBWYWxpZGF0aW9uIGFuZCBTYW5pdGl6YXRpb24gcHJvdG90eXBlcy4gSW5zcGVjdGlvblxuICAvLyBjb25zdHJ1Y3RvciBzaGFsbCBiZSBjYWxsZWQgaW4gZGVyaXZlZCBjbGFzcyBjb25zdHJ1Y3Rvci5cblxuICBmdW5jdGlvbiBJbnNwZWN0aW9uKHNjaGVtYSwgY3VzdG9tKSB7XG4gICAgdmFyIF9zdGFjayA9IFsnQCddO1xuXG4gICAgdGhpcy5fc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuX2N1c3RvbSA9IHt9O1xuICAgIGlmIChjdXN0b20gIT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGN1c3RvbSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1c3RvbSwga2V5KSkge1xuICAgICAgICAgIHRoaXMuX2N1c3RvbVsnJCcgKyBrZXldID0gY3VzdG9tW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9nZXREZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfc3RhY2subGVuZ3RoO1xuICAgIH07XG5cbiAgICB0aGlzLl9kdW1wU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG4gICAgICByZXR1cm4gX3N0YWNrLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5yZXBsYWNlKC9eXFxbL2csICdcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlJyk7IH0pXG4gICAgICAgIC5qb2luKCcuJykucmVwbGFjZSgvXFwuXFx1MDAxYlxcdTAwMWNcXHUwMDFkXFx1MDAxZS9nLCAnWycpO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG4gICAgfTtcblxuICAgIHRoaXMuX2RlZXBlck9iamVjdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfc3RhY2sucHVzaCgoL15bYS16JF9dW2EtejAtOSRfXSokL2kpLnRlc3QobmFtZSkgPyBuYW1lIDogJ1tcIicgKyBuYW1lICsgJ1wiXScpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuX2RlZXBlckFycmF5ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIF9zdGFjay5wdXNoKCdbJyArIGkgKyAnXScpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuX2JhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfc3RhY2sucG9wKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG4gIC8vIFNpbXBsZSB0eXBlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgbm90IGRlZmluZWQgb3IgaXMgbm90IGluIHRoaXMgbGlzdDpcbiAgdmFyIF90eXBlSXMgPSB7XG4gICAgZnVuY3Rpb246IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdmdW5jdGlvbic7XG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnO1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oZWxlbWVudCk7XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJyAmJiBlbGVtZW50ICUgMSA9PT0gMDtcbiAgICB9LFxuICAgIE5hTjogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicgJiYgaXNOYU4oZWxlbWVudCk7XG4gICAgfSxcbiAgICBib29sZWFuOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnYm9vbGVhbic7XG4gICAgfSxcbiAgICBudWxsOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IG51bGw7XG4gICAgfSxcbiAgICBkYXRlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50IGluc3RhbmNlb2YgRGF0ZTtcbiAgICB9LFxuICAgIG9iamVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQuY29uc3RydWN0b3IgIT09IEFycmF5O1xuICAgIH0sXG4gICAgYXJyYXk6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQuY29uc3RydWN0b3IgPT09IEFycmF5O1xuICAgIH0sXG4gICAgYW55OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gX3NpbXBsZVR5cGUodHlwZSwgY2FuZGlkYXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2FuZGlkYXRlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gICAgdHlwZSA9IHR5cGUgaW4gX3R5cGVJcyA/IHR5cGUgOiAnYW55JztcbiAgICByZXR1cm4gX3R5cGVJc1t0eXBlXShjYW5kaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3JlYWxUeXBlKGNhbmRpZGF0ZSkge1xuICAgIGZvciAodmFyIGkgaW4gX3R5cGVJcykge1xuICAgICAgaWYgKF9zaW1wbGVUeXBlKGksIGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgaWYgKGkgIT09ICdhbnknICYmIChpICE9PSAnb2JqZWN0JyB8fCBjYW5kaWRhdGUuY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHsgcmV0dXJuIGk7IH1cbiAgICAgICAgcmV0dXJuICdhbiBpbnN0YW5jZSBvZiAnICsgY2FuZGlkYXRlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5kZXhlcyhhLCB2YWx1ZSkge1xuICAgIHZhciBpbmRleGVzID0gW107XG4gICAgdmFyIGkgPSBhLmluZGV4T2YodmFsdWUpO1xuXG4gICAgd2hpbGUgKGkgIT09IC0xKSB7XG4gICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICBpID0gYS5pbmRleE9mKHZhbHVlLCBpICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLy8gQXZhaWxhYmxlIGZvcm1hdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG4gIC8vIFRPRE86IFN0dWR5IHRoZXNlIHJlZ2V4IGV4cHJlc3Npb25zIGFuZCBhZGQgbW9yZSB0ZXN0cyBzbyB3ZSBjYW4gY29uc2lkZXIgcmVtb3ZpbmdcbiAgLy8gcnVsZSBuby11c2VsZXNzLWVzY2FwZS5cbiAgdmFyIF9mb3JtYXRzID0ge1xuICAgIHZvaWQ6IC9eJC8sXG4gICAgdXJsOiAvXihodHRwcz98ZnRwKTpcXC9cXC8oKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OikqQCk/KCgoXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pKXwoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKT8oKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4/KSg6XFxkKik/KShcXC8oKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKyhcXC8oKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkqKSopPyk/KFxcPygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8W1xcdUUwMDAtXFx1RjhGRl18XFwvfFxcPykqKT8oXFwjKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxcXC98XFw/KSopPyQvaSxcbiAgICAnZGF0ZS10aW1lJzogL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGR7M30pPyhaP3woLXxcXCspXFxkezJ9OlxcZHsyfSkkLyxcbiAgICBkYXRlOiAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8sXG4gICAgY29vbERhdGVUaW1lOiAvXlxcZHs0fSgtfFxcLylcXGR7Mn0oLXxcXC8pXFxkezJ9KFR8IClcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGR7M30pP1o/JC8sXG4gICAgdGltZTogL15cXGR7Mn1cXDpcXGR7Mn1cXDpcXGR7Mn0kLyxcbiAgICBjb2xvcjogL14jKFswLTlhLWZdKSskL2ksXG4gICAgLy8gVmVyeSBmbGV4aWJsZSByZWd1bGFyIGV4cHJlc3Npb24gZGVzaWduZWQgdG8gY2F0Y2ggb25seSBvYnZpb3VzIG1pc3Rha2VzXG4gICAgLy8gdGhhdCBhIHVzZXIgbWlnaHQgbWFrZSB0aGF0IHdvdWxkIGhhdmUgYSAxMDAlIGNoYW5jZSBvZiBjYXVzaW5nIGVtYWlsXG4gICAgLy8gZGVsaXZlcnkgdG8gdGhlIGFkZHJlc3MgdG8gZmFpbC4gVGhlIGxpYnJhcnkgdGFrZXMgYSBmbGV4aWJsZSBvdmVyXG4gICAgLy8gc3RyaWN0IGFwcHJvYWNoLiBVc2VycyBzaG91bGQgdXNlIHRoaXMgb25seSBmb3IgYmFzaWMgZnJvbnQgZW5kIGVtYWlsXG4gICAgLy8gYWRkcmVzcyB2YWxpZGF0aW9uIGFuZCBwZXJmb3JtIG1vcmUgc3RyaWN0IGNoZWNraW5nIHVzaW5nIHNlcnZlci1zaWRlXG4gICAgLy8gY29kZSBhZnRlciB0aGUgZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZWlyIHNlcnZlci5cbiAgICAvLyBTb3VyY2VkIGZyb20gaHR0cHM6Ly93d3cucmVndWxhci1leHByZXNzaW9ucy5pbmZvL2VtYWlsLmh0bWwsIG1vZGlmaWVkXG4gICAgLy8gdG8gYWxsb3cgbG93ZXJjYXNlIGNoYXJhY3RlcnMgdG9vLlxuICAgIGVtYWlsOiAvXlteQF0rQFteLl0rXFwuW2EtekEtWl0rJC8sXG4gICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItcmVnZXgtbGl0ZXJhbHMgKi9cbiAgICAvKiBlc2xpbnQtZW5hYmxlIHF1b3RlcyAqL1xuICAgIG51bWVyaWM6IC9eWzAtOV0rJC8sXG4gICAgaW50ZWdlcjogL15cXC0/WzAtOV0rJC8sXG4gICAgZGVjaW1hbDogL15cXC0/WzAtOV0qXFwuP1swLTldKyQvLFxuICAgIGFscGhhOiAvXlthLXpdKyQvaSxcbiAgICBhbHBoYU51bWVyaWM6IC9eW2EtejAtOV0rJC9pLFxuICAgIGFscGhhRGFzaDogL15bYS16MC05Xy1dKyQvaSxcbiAgICBqYXZhc2NyaXB0OiAvXlthLXpfXFwkXVthLXowLTlfXFwkXSokL2ksXG4gICAgdXBwZXJTdHJpbmc6IC9eW0EtWiBdKiQvLFxuICAgIGxvd2VyU3RyaW5nOiAvXlthLXogXSokLyxcbiAgICB2NHV1aWQ6IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kL2lcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xuXG4gIC8vIFZhbGlkYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBfdmFsaWRhdGlvbkF0dHJpYnV0ID0ge1xuICAgIG9wdGlvbmFsOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBvcHQgPSB0eXBlb2Ygc2NoZW1hLm9wdGlvbmFsID09PSAnYm9vbGVhbicgPyBzY2hlbWEub3B0aW9uYWwgOiAoc2NoZW1hLm9wdGlvbmFsID09PSAndHJ1ZScpOyAvLyBEZWZhdWx0IGlzIGZhbHNlXG5cbiAgICAgIGlmIChvcHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdpcyBtaXNzaW5nIGFuZCBub3Qgb3B0aW9uYWwnLCBudWxsLCAnb3B0aW9uYWwnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHR5cGU6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgLy8gcmV0dXJuIGJlY2F1c2Ugb3B0aW9uYWwgZnVuY3Rpb24gYWxyZWFkeSBoYW5kbGUgdGhpcyBjYXNlXG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgKHR5cGVvZiBzY2hlbWEudHlwZSAhPT0gJ3N0cmluZycgJiYgIShzY2hlbWEudHlwZSBpbnN0YW5jZW9mIEFycmF5KSAmJiB0eXBlb2Ygc2NoZW1hLnR5cGUgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlcyA9IF90eXBlSXMuYXJyYXkoc2NoZW1hLnR5cGUpID8gc2NoZW1hLnR5cGUgOiBbc2NoZW1hLnR5cGVdO1xuICAgICAgdmFyIHR5cGVJc1ZhbGlkID0gdHlwZXMuc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gX3NpbXBsZVR5cGUodHlwZSwgY2FuZGlkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0eXBlSXNWYWxpZCkge1xuICAgICAgICB0eXBlcyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdHlwZW9mIHQgPT09ICdmdW5jdGlvbicgPyAnYW4gaW5zdGFuY2Ugb2YgJyArIHQubmFtZSA6IHQ7IH0pO1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSAnICsgdHlwZXMuam9pbignIG9yICcpICsgJywgYnV0IGlzICcgKyBfcmVhbFR5cGUoY2FuZGlkYXRlKSwgbnVsbCwgJ3R5cGUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVuaXF1ZW5lc3M6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEudW5pcXVlbmVzcyA9PT0gJ3N0cmluZycpIHsgc2NoZW1hLnVuaXF1ZW5lc3MgPSAoc2NoZW1hLnVuaXF1ZW5lc3MgPT09ICd0cnVlJyk7IH1cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnVuaXF1ZW5lc3MgIT09ICdib29sZWFuJyB8fCBzY2hlbWEudW5pcXVlbmVzcyA9PT0gZmFsc2UgfHwgKCFfdHlwZUlzLmFycmF5KGNhbmRpZGF0ZSkgJiYgdHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXBvcnRlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlcG9ydGVkLmluZGV4T2YoY2FuZGlkYXRlW2ldKSA+PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ZXMgPSBnZXRJbmRleGVzKGNhbmRpZGF0ZSwgY2FuZGlkYXRlW2ldKTtcbiAgICAgICAgaWYgKGluZGV4ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJlcG9ydGVkLnB1c2goY2FuZGlkYXRlW2ldKTtcbiAgICAgICAgICB0aGlzLnJlcG9ydCgnaGFzIHZhbHVlIFsnICsgY2FuZGlkYXRlW2ldICsgJ10gbW9yZSB0aGFuIG9uY2UgYXQgaW5kZXhlcyBbJyArIGluZGV4ZXMuam9pbignLCAnKSArICddJywgbnVsbCwgJ3VuaXF1ZW5lc3MnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGF0dGVybjogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcmVnZXhzID0gc2NoZW1hLnBhdHRlcm47XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgIGlmICghX3R5cGVJcy5hcnJheShyZWdleHMpKSB7XG4gICAgICAgIHJlZ2V4cyA9IFtyZWdleHNdO1xuICAgICAgfVxuICAgICAgcmVnZXhzLmZvckVhY2goZnVuY3Rpb24gKHJlZ2V4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVnZXggPT09ICdzdHJpbmcnICYmIHJlZ2V4IGluIF9mb3JtYXRzKSB7XG4gICAgICAgICAgcmVnZXggPSBfZm9ybWF0c1tyZWdleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgaWYgKHJlZ2V4LnRlc3QoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICBzZWxmLnJlcG9ydCgnbXVzdCBtYXRjaCBbJyArIHJlZ2V4cy5qb2luKCcgb3IgJykgKyAnXSwgYnV0IGlzIGVxdWFsIHRvIFwiJyArIGNhbmRpZGF0ZSArICdcIicsIG51bGwsICdwYXR0ZXJuJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZERhdGU6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKFN0cmluZyhzY2hlbWEudmFsaWREYXRlKSA9PT0gJ3RydWUnICYmIGNhbmRpZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgaXNOYU4oY2FuZGlkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgYSB2YWxpZCBkYXRlJywgbnVsbCwgJ3ZhbGlkRGF0ZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWluTGVuZ3RoOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnc3RyaW5nJyAmJiAhX3R5cGVJcy5hcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5MZW5ndGggPSBOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCk7XG4gICAgICBpZiAoaXNOYU4obWluTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBsb25nZXIgdGhhbiAnICsgbWluTGVuZ3RoICsgJyBlbGVtZW50cywgYnV0IGl0IGhhcyAnICsgY2FuZGlkYXRlLmxlbmd0aCwgbnVsbCwgJ21pbkxlbmd0aCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWF4TGVuZ3RoOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnc3RyaW5nJyAmJiAhX3R5cGVJcy5hcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtYXhMZW5ndGggPSBOdW1iZXIoc2NoZW1hLm1heExlbmd0aCk7XG4gICAgICBpZiAoaXNOYU4obWF4TGVuZ3RoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBzaG9ydGVyIHRoYW4gJyArIG1heExlbmd0aCArICcgZWxlbWVudHMsIGJ1dCBpdCBoYXMgJyArIGNhbmRpZGF0ZS5sZW5ndGgsIG51bGwsICdtYXhMZW5ndGgnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4YWN0TGVuZ3RoOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnc3RyaW5nJyAmJiAhX3R5cGVJcy5hcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBleGFjdExlbmd0aCA9IE51bWJlcihzY2hlbWEuZXhhY3RMZW5ndGgpO1xuICAgICAgaWYgKGlzTmFOKGV4YWN0TGVuZ3RoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlLmxlbmd0aCAhPT0gZXhhY3RMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgaGF2ZSBleGFjdGx5ICcgKyBleGFjdExlbmd0aCArICcgZWxlbWVudHMsIGJ1dCBpdCBoYXZlICcgKyBjYW5kaWRhdGUubGVuZ3RoLCBudWxsLCAnZXhhY3RMZW5ndGgnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGx0OiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBsaW1pdCA9IE51bWJlcihzY2hlbWEubHQpO1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGxpbWl0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlID49IGxpbWl0KSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGxlc3MgdGhhbiAnICsgbGltaXQgKyAnLCBidXQgaXMgZXF1YWwgdG8gXCInICsgY2FuZGlkYXRlICsgJ1wiJywgbnVsbCwgJ2x0Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsdGU6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgdmFyIGxpbWl0ID0gTnVtYmVyKHNjaGVtYS5sdGUpO1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGxpbWl0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlID4gbGltaXQpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICcgKyBsaW1pdCArICcsIGJ1dCBpcyBlcXVhbCB0byBcIicgKyBjYW5kaWRhdGUgKyAnXCInLCBudWxsLCAnbHRlJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBndDogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIoc2NoZW1hLmd0KTtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnbnVtYmVyJyB8fCBpc05hTihsaW1pdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZSA8PSBsaW1pdCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBncmVhdGVyIHRoYW4gJyArIGxpbWl0ICsgJywgYnV0IGlzIGVxdWFsIHRvIFwiJyArIGNhbmRpZGF0ZSArICdcIicsIG51bGwsICdndCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ3RlOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBsaW1pdCA9IE51bWJlcihzY2hlbWEuZ3RlKTtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnbnVtYmVyJyB8fCBpc05hTihsaW1pdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZSA8IGxpbWl0KSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAnICsgbGltaXQgKyAnLCBidXQgaXMgZXF1YWwgdG8gXCInICsgY2FuZGlkYXRlICsgJ1wiJywgbnVsbCwgJ2d0ZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXE6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdudW1iZXInICYmIHR5cGVvZiBjYW5kaWRhdGUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBjYW5kaWRhdGUgIT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgPSBzY2hlbWEuZXE7XG4gICAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGltaXQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBsaW1pdCAhPT0gJ2Jvb2xlYW4nICYmICFfdHlwZUlzLmFycmF5KGxpbWl0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShsaW1pdCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT09IGxpbWl0W2ldKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGVxdWFsIHRvIFsnICsgbGltaXQubWFwKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgcmV0dXJuICdcIicgKyBsICsgJ1wiJztcbiAgICAgICAgfSkuam9pbignIG9yICcpICsgJ10sIGJ1dCBpcyBlcXVhbCB0byBcIicgKyBjYW5kaWRhdGUgKyAnXCInLCBudWxsLCAnZXEnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgIT09IGxpbWl0KSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgZXF1YWwgdG8gXCInICsgbGltaXQgKyAnXCIsIGJ1dCBpcyBlcXVhbCB0byBcIicgKyBjYW5kaWRhdGUgKyAnXCInLCBudWxsLCAnZXEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbmU6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdudW1iZXInICYmIHR5cGVvZiBjYW5kaWRhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaW1pdCA9IHNjaGVtYS5uZTtcbiAgICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInICYmIHR5cGVvZiBsaW1pdCAhPT0gJ3N0cmluZycgJiYgIV90eXBlSXMuYXJyYXkobGltaXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KGxpbWl0KSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gbGltaXRbaV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IG5vdCBiZSBlcXVhbCB0byBcIicgKyBsaW1pdFtpXSArICdcIicsIG51bGwsICduZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gbGltaXQpIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBub3QgYmUgZXF1YWwgdG8gXCInICsgbGltaXQgKyAnXCInLCBudWxsLCAnbmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbXVsdGlwbGVPZjogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBjb25zdCBkaXZpc29yID0gTnVtYmVyKHNjaGVtYS5tdWx0aXBsZU9mKTtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnbnVtYmVyJyB8fCBpc05hTihkaXZpc29yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlICUgZGl2aXNvciAhPT0gMCkge1xuICAgICAgICB0aGlzLnJlcG9ydChjYW5kaWRhdGUgKyAnIGlzIG5vdCBkaXZpc2libGUgYnkgJyArIGRpdmlzb3IsIG51bGwsICdtdWx0aXBsZU9mJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzb21lS2V5czogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXQpIHtcbiAgICAgIHZhciBfa2V5cyA9IHNjaGVtYS5zb21lS2V5cztcbiAgICAgIGlmICghX3R5cGVJcy5vYmplY3QoY2FuZGlkYXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxpZCA9IF9rZXlzLnNvbWUoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gKGFjdGlvbiBpbiBjYW5kaWRhdCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgaGF2ZSBhdCBsZWFzdCBrZXkgJyArIF9rZXlzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiAnXCInICsgaSArICdcIic7XG4gICAgICAgIH0pLmpvaW4oJyBvciAnKSwgbnVsbCwgJ3NvbWVLZXlzJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdHJpY3Q6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuc3RyaWN0ID09PSAnc3RyaW5nJykgeyBzY2hlbWEuc3RyaWN0ID0gKHNjaGVtYS5zdHJpY3QgPT09ICd0cnVlJyk7IH1cbiAgICAgIGlmIChzY2hlbWEuc3RyaWN0ICE9PSB0cnVlIHx8ICFfdHlwZUlzLm9iamVjdChjYW5kaWRhdGUpIHx8ICFfdHlwZUlzLm9iamVjdChzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEucHJvcGVydGllc1snKiddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaW50cnVkZXIgPSBPYmplY3Qua2V5cyhjYW5kaWRhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuICh0eXBlb2Ygc2NoZW1hLnByb3BlcnRpZXNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludHJ1ZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbXNnID0gJ3Nob3VsZCBub3QgY29udGFpbnMgJyArIChpbnRydWRlci5sZW5ndGggPiAxID8gJ3Byb3BlcnRpZXMnIDogJ3Byb3BlcnR5JykgK1xuICAgICAgICAgICAgJyBbJyArIGludHJ1ZGVyLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gJ1wiJyArIGkgKyAnXCInOyB9KS5qb2luKCcsICcpICsgJ10nO1xuICAgICAgICAgIHNlbGYucmVwb3J0KG1zZywgbnVsbCwgJ3N0cmljdCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBleGVjOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNFeGVjKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAoX3R5cGVJcy5hcnJheShzY2hlbWEuZXhlYykgPyBzY2hlbWEuZXhlYyA6IFtzY2hlbWEuZXhlY10pLmZvckVhY2goZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXhlYy5jYWxsKHNlbGYsIHNjaGVtYSwgY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jUHJvcGVydGllcyhzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoc2NoZW1hLnByb3BlcnRpZXMgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICEoY2FuZGlkYXRlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAocHJvcGVydGllc1snKiddICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpIGluIGNhbmRpZGF0ZSkge1xuICAgICAgICAgIGlmIChpIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgICAgdGhpcy5fdmFsaWRhdGUocHJvcGVydGllc1snKiddLCBjYW5kaWRhdGVbaV0pO1xuICAgICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGkgPT09ICcqJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUocHJvcGVydGllc1tpXSwgY2FuZGlkYXRlW2ldKTtcbiAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbXM6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNJdGVtcyhzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoc2NoZW1hLml0ZW1zIGluc3RhbmNlb2YgT2JqZWN0KSB8fCAhKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuICAgICAgdmFyIGksIGw7XG4gICAgICAvLyBJZiBwcm92aWRlZCBzY2hlbWEgaXMgYW4gYXJyYXlcbiAgICAgIC8vIHRoZW4gY2FsbCB2YWxpZGF0ZSBmb3IgZWFjaCBjYXNlXG4gICAgICAvLyBlbHNlIGl0IGlzIGFuIE9iamVjdFxuICAgICAgLy8gdGhlbiBjYWxsIHZhbGlkYXRlIGZvciBlYWNoIGtleVxuICAgICAgaWYgKF90eXBlSXMuYXJyYXkoaXRlbXMpICYmIF90eXBlSXMuYXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fZGVlcGVyQXJyYXkoaSk7XG4gICAgICAgICAgdGhpcy5fdmFsaWRhdGUoaXRlbXNbaV0sIGNhbmRpZGF0ZVtpXSk7XG4gICAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FuZGlkYXRlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjYW5kaWRhdGUsIGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZXBlckFycmF5KGtleSk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShpdGVtcywgY2FuZGlkYXRlW2tleV0pO1xuICAgICAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX2FzeW5jVmFsaWRhdGlvbkF0dHJpYnV0ID0ge1xuICAgIGFzeW5jRXhlYzogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgYXN5bmMuZWFjaFNlcmllcyhfdHlwZUlzLmFycmF5KHNjaGVtYS5leGVjKSA/IHNjaGVtYS5leGVjIDogW3NjaGVtYS5leGVjXSwgZnVuY3Rpb24gKGV4ZWMsIGRvbmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGV4ZWMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWMuY2FsbChzZWxmLCBzY2hlbWEsIGNhbmRpZGF0ZSwgZG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4ZWMuY2FsbChzZWxmLCBzY2hlbWEsIGNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMubmV4dFRpY2soZG9uZSk7XG4gICAgICB9LCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBhc3luY1Byb3BlcnRpZXM6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghKHNjaGVtYS5wcm9wZXJ0aWVzIGluc3RhbmNlb2YgT2JqZWN0KSB8fCAhX3R5cGVJcy5vYmplY3QoY2FuZGlkYXRlKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICBhc3luYy5zZXJpZXMoW1xuICAgICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzWycqJ10gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhjYW5kaWRhdGUpLCBmdW5jdGlvbiAoaSwgZG9uZSkge1xuICAgICAgICAgICAgaWYgKGkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICByZXR1cm4gYXN5bmMubmV4dFRpY2soZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgICAgICBzZWxmLl9hc3luY1ZhbGlkYXRlKHByb3BlcnRpZXNbJyonXSwgY2FuZGlkYXRlW2ldLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgbmV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgZnVuY3Rpb24gKGksIGRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAnKicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jLm5leHRUaWNrKGRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICAgICAgc2VsZi5fYXN5bmNWYWxpZGF0ZShwcm9wZXJ0aWVzW2ldLCBjYW5kaWRhdGVbaV0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgXSwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgYXN5bmNJdGVtczogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCEoc2NoZW1hLml0ZW1zIGluc3RhbmNlb2YgT2JqZWN0KSB8fCAhKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaXRlbXMgPSBzY2hlbWEuaXRlbXM7XG5cbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KGl0ZW1zKSAmJiBfdHlwZUlzLmFycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgYXN5bmMudGltZXNTZXJpZXMoaXRlbXMubGVuZ3RoLCBmdW5jdGlvbiAoaSwgZG9uZSkge1xuICAgICAgICAgIHNlbGYuX2RlZXBlckFycmF5KGkpO1xuICAgICAgICAgIHNlbGYuX2FzeW5jVmFsaWRhdGUoaXRlbXNbaV0sIGNhbmRpZGF0ZVtpXSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICBkb25lKGVyciwgcmVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMoY2FuZGlkYXRlKSwgZnVuY3Rpb24gKGtleSwgZG9uZSkge1xuICAgICAgICAgIHNlbGYuX2RlZXBlckFycmF5KGtleSk7XG4gICAgICAgICAgc2VsZi5fYXN5bmNWYWxpZGF0ZShpdGVtcywgY2FuZGlkYXRlW2tleV0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgZG9uZShlcnIsIHJlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVmFsaWRhdGlvbiBDbGFzcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGluaGVyaXRzIGZyb20gSW5zcGVjdGlvbiBjbGFzcyAoYWN0dWFsbHkgd2UganVzdCBjYWxsIEluc3BlY3Rpb25cbiAgLy8gY29uc3RydWN0b3Igd2l0aCB0aGUgbmV3IGNvbnRleHQsIGJlY2F1c2UgaXRzIHByb3RvdHlwZSBpcyBlbXB0eVxuICBmdW5jdGlvbiBWYWxpZGF0aW9uKHNjaGVtYSwgY3VzdG9tKSB7XG4gICAgSW5zcGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBzY2hlbWEsIF9tZXJnZShWYWxpZGF0aW9uLmN1c3RvbSwgY3VzdG9tKSk7XG4gICAgdmFyIF9lcnJvciA9IFtdO1xuXG4gICAgdGhpcy5fYmFzaWNGaWVsZHMgPSBPYmplY3Qua2V5cyhfdmFsaWRhdGlvbkF0dHJpYnV0KTtcbiAgICB0aGlzLl9jdXN0b21GaWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9jdXN0b20pO1xuICAgIHRoaXMub3JpZ2luID0gbnVsbDtcblxuICAgIHRoaXMucmVwb3J0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGNvZGUsIHJlYXNvbikge1xuICAgICAgdmFyIG5ld0VyciA9IHtcbiAgICAgICAgY29kZTogY29kZSB8fCB0aGlzLnVzZXJDb2RlIHx8IG51bGwsXG4gICAgICAgIHJlYXNvbjogcmVhc29uIHx8ICd1bmtub3duJyxcbiAgICAgICAgbWVzc2FnZTogdGhpcy51c2VyRXJyb3IgfHwgbWVzc2FnZSB8fCAnaXMgaW52YWxpZCcsXG4gICAgICAgIHByb3BlcnR5OiB0aGlzLnVzZXJBbGlhcyA/ICh0aGlzLnVzZXJBbGlhcyArICcgKCcgKyB0aGlzLl9kdW1wU3RhY2soKSArICcpJykgOiB0aGlzLl9kdW1wU3RhY2soKVxuICAgICAgfTtcbiAgICAgIF9lcnJvci5wdXNoKG5ld0Vycik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5yZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogX2Vycm9yLFxuICAgICAgICB2YWxpZDogX2Vycm9yLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2FuZGlkYXRlIGlzIHZhbGlkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1Byb3BlcnR5ICcgKyBpLnByb3BlcnR5ICsgJzogJyArIGkubWVzc2FnZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgX2V4dGVuZChWYWxpZGF0aW9uLnByb3RvdHlwZSwgX3ZhbGlkYXRpb25BdHRyaWJ1dCk7XG4gIF9leHRlbmQoVmFsaWRhdGlvbi5wcm90b3R5cGUsIF9hc3luY1ZhbGlkYXRpb25BdHRyaWJ1dCk7XG4gIF9leHRlbmQoVmFsaWRhdGlvbiwgbmV3IEN1c3RvbWlzYWJsZSgpKTtcblxuICBWYWxpZGF0aW9uLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vcmlnaW4gPSBjYW5kaWRhdGU7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fYXN5bmNWYWxpZGF0ZShzZWxmLl9zY2hlbWEsIGNhbmRpZGF0ZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHNlbGYub3JpZ2luID0gbnVsbDtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIHNlbGYucmVzdWx0KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGUodGhpcy5fc2NoZW1hLCBjYW5kaWRhdGUpLnJlc3VsdCgpO1xuICB9O1xuXG4gIFZhbGlkYXRpb24ucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVzZXJDb2RlID0gc2NoZW1hLmNvZGUgfHwgbnVsbDtcbiAgICB0aGlzLnVzZXJFcnJvciA9IHNjaGVtYS5lcnJvciB8fCBudWxsO1xuICAgIHRoaXMudXNlckFsaWFzID0gc2NoZW1hLmFsaWFzIHx8IG51bGw7XG4gICAgdGhpcy5fYmFzaWNGaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgaWYgKChpIGluIHNjaGVtYSB8fCBpID09PSAnb3B0aW9uYWwnKSAmJiB0eXBlb2YgdGhpc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ldKHNjaGVtYSwgY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9jdXN0b21GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgaWYgKGkgaW4gc2NoZW1hICYmIHR5cGVvZiB0aGlzLl9jdXN0b21baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY3VzdG9tW2ldLmNhbGwodGhpcywgc2NoZW1hLCBjYW5kaWRhdGUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFZhbGlkYXRpb24ucHJvdG90eXBlLl9hc3luY1ZhbGlkYXRlID0gZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnVzZXJDb2RlID0gc2NoZW1hLmNvZGUgfHwgbnVsbDtcbiAgICB0aGlzLnVzZXJFcnJvciA9IHNjaGVtYS5lcnJvciB8fCBudWxsO1xuICAgIHRoaXMudXNlckFsaWFzID0gc2NoZW1hLmFsaWFzIHx8IG51bGw7XG5cbiAgICBhc3luYy5zZXJpZXMoW1xuICAgICAgZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhfdmFsaWRhdGlvbkF0dHJpYnV0KSwgZnVuY3Rpb24gKGksIGRvbmUpIHtcbiAgICAgICAgICBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKGkgaW4gc2NoZW1hIHx8IGkgPT09ICdvcHRpb25hbCcpICYmIHR5cGVvZiBzZWxmW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmW2ldLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZltpXShzY2hlbWEsIGNhbmRpZGF0ZSwgZG9uZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZltpXShzY2hlbWEsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIG5leHQpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMoc2VsZi5fY3VzdG9tKSwgZnVuY3Rpb24gKGksIGRvbmUpIHtcbiAgICAgICAgICBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzY2hlbWEgJiYgdHlwZW9mIHNlbGYuX2N1c3RvbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5fY3VzdG9tW2ldLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fY3VzdG9tW2ldLmNhbGwoc2VsZiwgc2NoZW1hLCBjYW5kaWRhdGUsIGRvbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuX2N1c3RvbVtpXS5jYWxsKHNlbGYsIHNjaGVtYSwgY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbmV4dCk7XG4gICAgICB9XG4gICAgXSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFNhbml0aXphdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGZ1bmN0aW9ucyBjYWxsZWQgYnkgX3Nhbml0aXphdGlvbi50eXBlIG1ldGhvZC5cbiAgdmFyIF9mb3JjZVR5cGUgPSB7XG4gICAgbnVtYmVyOiBmdW5jdGlvbiAocG9zdCwgc2NoZW1hKSB7XG4gICAgICB2YXIgbjtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9IGVsc2UgaWYgKHBvc3QgPT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmRlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hLmRlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG4gPSBwYXJzZUZsb2F0KHBvc3QucmVwbGFjZSgvLC9nLCAnLicpLnJlcGxhY2UoLyAvZywgJycpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBvc3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiArcG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKHBvc3QsIHNjaGVtYSkge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAodHlwZW9mIHBvc3QgPT09ICdudW1iZXInICYmIHBvc3QgJSAxID09PSAwKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfSBlbHNlIGlmIChwb3N0ID09PSAnJykge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5kZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVtYS5kZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwb3N0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBuID0gcGFyc2VJbnQocG9zdC5yZXBsYWNlKC8gL2csICcnKSwgMTApO1xuICAgICAgICBpZiAodHlwZW9mIG4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBvc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChwb3N0LCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwb3N0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKHBvc3QpIHsgcmV0dXJuIDE7IH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHBvc3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiArcG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc3RyaW5nOiBmdW5jdGlvbiAocG9zdCwgc2NoZW1hKSB7XG4gICAgICBpZiAodHlwZW9mIHBvc3QgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgcG9zdCA9PT0gJ251bWJlcicgfHwgcG9zdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBvc3QudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVJcy5hcnJheShwb3N0KSkge1xuICAgICAgICAvLyBJZiB1c2VyIGF1dGhvcml6ZSBhcnJheSBhbmQgc3RyaW5ncy4uLlxuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zIHx8IHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc3Quam9pbihTdHJpbmcoc2NoZW1hLmpvaW5XaXRoIHx8ICcsJykpO1xuICAgICAgfSBlbHNlIGlmIChwb3N0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIC8vIElmIHVzZXIgYXV0aG9yaXplIG9iamVjdHMgYW5zIHN0cmluZ3MuLi5cbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyB8fCBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwb3N0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBvc3QgPT09ICdzdHJpbmcnICYmIHBvc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBkYXRlOiBmdW5jdGlvbiAocG9zdCwgc2NoZW1hKSB7XG4gICAgICBpZiAocG9zdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHBvc3QpO1xuICAgICAgICBpZiAoIWlzTmFOKGQuZ2V0VGltZSgpKSkgeyAvLyBpZiB2YWxpZCBkYXRlXG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgYm9vbGVhbjogZnVuY3Rpb24gKHBvc3QsIHNjaGVtYSkge1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIHBvc3QgPT09ICdzdHJpbmcnICYmIHBvc3QudG9Mb3dlckNhc2UoKSA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuICEhcG9zdDtcbiAgICB9LFxuICAgIG9iamVjdDogZnVuY3Rpb24gKHBvc3QsIHNjaGVtYSkge1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ICE9PSAnc3RyaW5nJyB8fCBfdHlwZUlzLm9iamVjdChwb3N0KSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHBvc3QpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFycmF5OiBmdW5jdGlvbiAocG9zdCwgc2NoZW1hKSB7XG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShwb3N0KSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcG9zdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChwb3N0LnN1YnN0cmluZygwLCAxKSA9PT0gJ1snICYmIHBvc3Quc2xpY2UoLTEpID09PSAnXScpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocG9zdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3N0LnNwbGl0KFN0cmluZyhzY2hlbWEuc3BsaXRXaXRoIHx8ICcsJykpO1xuICAgICAgfVxuICAgICAgaWYgKCFfdHlwZUlzLmFycmF5KHBvc3QpKSB7XG4gICAgICAgIHJldHVybiBbcG9zdF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9hcHBseVJ1bGVzID0ge1xuICAgIHVwcGVyOiBmdW5jdGlvbiAocG9zdCkge1xuICAgICAgcmV0dXJuIHBvc3QudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIGxvd2VyOiBmdW5jdGlvbiAocG9zdCkge1xuICAgICAgcmV0dXJuIHBvc3QudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuICAgIHRpdGxlOiBmdW5jdGlvbiAocG9zdCkge1xuICAgICAgLy8gRml4IGJ5IHNlYiAocmVwbGFjZSBcXHdcXFMqIGJ5IFxcUyogPT4gZXhlbXBsZSA6IGNvdWNvdSDDp2EgdmEpXG4gICAgICByZXR1cm4gcG9zdC5yZXBsYWNlKC9cXFMqL2csIGZ1bmN0aW9uICh0eHQpIHtcbiAgICAgICAgcmV0dXJuIHR4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgIHJldHVybiBwb3N0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcG9zdC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuICAgIHVjZmlyc3Q6IGZ1bmN0aW9uIChwb3N0KSB7XG4gICAgICByZXR1cm4gcG9zdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHBvc3Quc3Vic3RyKDEpO1xuICAgIH0sXG4gICAgdHJpbTogZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgIHJldHVybiBwb3N0LnRyaW0oKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRXZlcnkgZnVuY3Rpb24gcmV0dXJuIHRoZSBmdXR1cmUgdmFsdWUgb2YgZWFjaCBwcm9wZXJ0eS4gVGhlcmVmb3JlIHlvdVxuICAvLyBoYXZlIHRvIHJldHVybiBwb3N0IGV2ZW4gaWYgeW91IGRvIG5vdCBjaGFuZ2UgaXRzIHZhbHVlXG4gIHZhciBfc2FuaXRpemF0aW9uQXR0cmlidXQgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS5zdHJpY3QgPT09ICdzdHJpbmcnKSB7IHNjaGVtYS5zdHJpY3QgPSAoc2NoZW1hLnN0cmljdCA9PT0gJ3RydWUnKTsgfVxuICAgICAgaWYgKHNjaGVtYS5zdHJpY3QgIT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBpZiAoIV90eXBlSXMub2JqZWN0KHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIGlmICghX3R5cGVJcy5vYmplY3QocG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBPYmplY3Qua2V5cyhwb3N0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIGRlbGV0ZSBwb3N0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBvcHRpb25hbDogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgdmFyIG9wdCA9IHR5cGVvZiBzY2hlbWEub3B0aW9uYWwgPT09ICdib29sZWFuJyA/IHNjaGVtYS5vcHRpb25hbCA6IChzY2hlbWEub3B0aW9uYWwgIT09ICdmYWxzZScpOyAvLyBEZWZhdWx0OiB0cnVlXG4gICAgICBpZiAob3B0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwb3N0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICBpZiAoc2NoZW1hLmRlZiA9PT0gRGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWEuZGVmO1xuICAgIH0sXG4gICAgdHlwZTogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgLy8gaWYgKF90eXBlSXNbJ29iamVjdCddKHBvc3QpIHx8IF90eXBlSXMuYXJyYXkocG9zdCkpIHtcbiAgICAgIC8vICAgcmV0dXJuIHBvc3Q7XG4gICAgICAvLyB9XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS50eXBlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgX2ZvcmNlVHlwZVtzY2hlbWEudHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB2YXIgbjtcbiAgICAgIHZhciBvcHQgPSB0eXBlb2Ygc2NoZW1hLm9wdGlvbmFsID09PSAnYm9vbGVhbicgPyBzY2hlbWEub3B0aW9uYWwgOiB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBfZm9yY2VUeXBlW3NjaGVtYS50eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBuID0gX2ZvcmNlVHlwZVtzY2hlbWEudHlwZV0ocG9zdCwgc2NoZW1hKTtcbiAgICAgICAgaWYgKChuID09PSBudWxsICYmICFvcHQpIHx8ICghbiAmJiBpc05hTihuKSkgfHwgKG4gPT09IG51bGwgJiYgc2NoZW1hLnR5cGUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIG4gPSBzY2hlbWEuZGVmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFvcHQpIHtcbiAgICAgICAgbiA9IHNjaGVtYS5kZWY7XG4gICAgICB9XG4gICAgICBpZiAoKG4gIT0gbnVsbCB8fCAodHlwZW9mIHNjaGVtYS5kZWYgIT09ICd1bmRlZmluZWQnICYmIHNjaGVtYS5kZWYgPT09IG4pKSAmJiBuICE9PSBwb3N0KSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBydWxlczogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgdmFyIHJ1bGVzID0gc2NoZW1hLnJ1bGVzO1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ICE9PSAnc3RyaW5nJyB8fCAodHlwZW9mIHJ1bGVzICE9PSAnc3RyaW5nJyAmJiAhX3R5cGVJcy5hcnJheShydWxlcykpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdmFyIG1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAoX3R5cGVJcy5hcnJheShydWxlcykgPyBydWxlcyA6IFtydWxlc10pLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfYXBwbHlSdWxlc1tydWxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHBvc3QgPSBfYXBwbHlSdWxlc1tydWxlXShwb3N0KTtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIG1pbjogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgdmFyIHBvc3RUZXN0ID0gTnVtYmVyKHBvc3QpO1xuICAgICAgaWYgKGlzTmFOKHBvc3RUZXN0KSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHZhciBtaW4gPSBOdW1iZXIoc2NoZW1hLm1pbik7XG4gICAgICBpZiAoaXNOYU4obWluKSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0VGVzdCA8IG1pbikge1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgICByZXR1cm4gbWluO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBtYXg6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIHZhciBwb3N0VGVzdCA9IE51bWJlcihwb3N0KTtcbiAgICAgIGlmIChpc05hTihwb3N0VGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB2YXIgbWF4ID0gTnVtYmVyKHNjaGVtYS5tYXgpO1xuICAgICAgaWYgKGlzTmFOKG1heCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBpZiAocG9zdFRlc3QgPiBtYXgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgbWluTGVuZ3RoOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIHBvc3QgIT09ICdzdHJpbmcnIHx8IGlzTmFOKGxpbWl0KSB8fCBsaW1pdCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB2YXIgZ2FwID0gbGltaXQgLSBwb3N0Lmxlbmd0aDtcbiAgICAgIGlmIChnYXAgPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FwOyBpKyspIHtcbiAgICAgICAgICBzdHIgKz0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICAgIHJldHVybiBwb3N0ICsgc3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBtYXhMZW5ndGg6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIHZhciBsaW1pdCA9IE51bWJlcihzY2hlbWEubWF4TGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCAhPT0gJ3N0cmluZycgfHwgaXNOYU4obGltaXQpIHx8IGxpbWl0IDwgMCkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0Lmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICAgIHJldHVybiBwb3N0LnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgcHJvcGVydGllczogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNQcm9wZXJ0aWVzKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCFwb3N0IHx8IHR5cGVvZiBwb3N0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXNbJyonXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9yIChpIGluIHBvc3QpIHtcbiAgICAgICAgICBpZiAoaSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICAgIHRtcCA9IHRoaXMuX3Nhbml0aXplKHByb3BlcnRpZXNbJyonXSwgcG9zdFtpXSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0bXAgIT09ICd1bmRlZmluZWQnIHx8ICdleGVjJyBpbiBwcm9wZXJ0aWVzWycqJ10pIHtcbiAgICAgICAgICAgIHBvc3RbaV0gPSB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGkgIT09ICcqJykge1xuICAgICAgICAgIHRoaXMuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgICB0bXAgPSB0aGlzLl9zYW5pdGl6ZShwcm9wZXJ0aWVzW2ldLCBwb3N0W2ldKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRtcCAhPT0gJ3VuZGVmaW5lZCcgfHwgJ2V4ZWMnIGluIHByb3BlcnRpZXNbaV0pIHtcbiAgICAgICAgICAgIHBvc3RbaV0gPSB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBpdGVtczogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNJdGVtcyhzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHNjaGVtYS5pdGVtcyBpbnN0YW5jZW9mIE9iamVjdCkgfHwgIShwb3N0IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgaWYgKF90eXBlSXMuYXJyYXkoc2NoZW1hLml0ZW1zKSAmJiBfdHlwZUlzLmFycmF5KHBvc3QpKSB7XG4gICAgICAgIHZhciBtaW5MZW5ndGggPSBzY2hlbWEuaXRlbXMubGVuZ3RoIDwgcG9zdC5sZW5ndGggPyBzY2hlbWEuaXRlbXMubGVuZ3RoIDogcG9zdC5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5MZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2RlZXBlckFycmF5KGkpO1xuICAgICAgICAgIHBvc3RbaV0gPSB0aGlzLl9zYW5pdGl6ZShzY2hlbWEuaXRlbXNbaV0sIHBvc3RbaV0pO1xuICAgICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIHBvc3QpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBvc3QsIGkpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWVwZXJBcnJheShpKTtcbiAgICAgICAgICAgIHBvc3RbaV0gPSB0aGlzLl9zYW5pdGl6ZShzY2hlbWEuaXRlbXMsIHBvc3RbaV0pO1xuICAgICAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBleGVjOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0V4ZWMoc2NoZW1hLCBwb3N0LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICB2YXIgZXhlY3MgPSBfdHlwZUlzLmFycmF5KHNjaGVtYS5leGVjKSA/IHNjaGVtYS5leGVjIDogW3NjaGVtYS5leGVjXTtcblxuICAgICAgZXhlY3MuZm9yRWFjaChmdW5jdGlvbiAoZXhlYykge1xuICAgICAgICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwb3N0ID0gZXhlYy5jYWxsKHRoaXMsIHNjaGVtYSwgcG9zdCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfYXN5bmNTYW5pdGl6YXRpb25BdHRyaWJ1dCA9IHtcbiAgICBhc3luY0V4ZWM6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXhlY3MgPSBfdHlwZUlzLmFycmF5KHNjaGVtYS5leGVjKSA/IHNjaGVtYS5leGVjIDogW3NjaGVtYS5leGVjXTtcblxuICAgICAgYXN5bmMuZWFjaFNlcmllcyhleGVjcywgZnVuY3Rpb24gKGV4ZWMsIGRvbmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGV4ZWMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWMuY2FsbChzZWxmLCBzY2hlbWEsIHBvc3QsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3N0ID0gcmVzO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zdCA9IGV4ZWMuY2FsbChzZWxmLCBzY2hlbWEsIHBvc3QpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCBwb3N0KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYXN5bmNQcm9wZXJ0aWVzOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFwb3N0IHx8IHR5cGVvZiBwb3N0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcG9zdCk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzO1xuXG4gICAgICBhc3luYy5zZXJpZXMoW1xuICAgICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzWycqJ10gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGdsb2JpbmcgPSBwcm9wZXJ0aWVzWycqJ107XG4gICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhwb3N0KSwgZnVuY3Rpb24gKGksIG5leHQpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgICAgIHNlbGYuX2FzeW5jU2FuaXRpemUoZ2xvYmluZywgcG9zdFtpXSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHsgLyogRXJyb3IgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGhlcmUgKi8gfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwb3N0W2ldID0gcmVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgbmV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgZnVuY3Rpb24gKGksIG5leHQpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAnKicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgICAgIHNlbGYuX2FzeW5jU2FuaXRpemUocHJvcGVydGllc1tpXSwgcG9zdFtpXSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBvc3RbaV0gPSByZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBwb3N0KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYXN5bmNJdGVtczogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghKHNjaGVtYS5pdGVtcyBpbnN0YW5jZW9mIE9iamVjdCkgfHwgIShwb3N0IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcG9zdCk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaXRlbXMgPSBzY2hlbWEuaXRlbXM7XG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShpdGVtcykgJiYgX3R5cGVJcy5hcnJheShwb3N0KSkge1xuICAgICAgICB2YXIgbWluTGVuZ3RoID0gaXRlbXMubGVuZ3RoIDwgcG9zdC5sZW5ndGggPyBpdGVtcy5sZW5ndGggOiBwb3N0Lmxlbmd0aDtcbiAgICAgICAgYXN5bmMudGltZXNTZXJpZXMobWluTGVuZ3RoLCBmdW5jdGlvbiAoaSwgbmV4dCkge1xuICAgICAgICAgIHNlbGYuX2RlZXBlckFycmF5KGkpO1xuICAgICAgICAgIHNlbGYuX2FzeW5jU2FuaXRpemUoaXRlbXNbaV0sIHBvc3RbaV0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdFtpXSA9IHJlcztcbiAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgcG9zdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhwb3N0KSwgZnVuY3Rpb24gKGtleSwgbmV4dCkge1xuICAgICAgICAgIHNlbGYuX2RlZXBlckFycmF5KGtleSk7XG4gICAgICAgICAgc2VsZi5fYXN5bmNTYW5pdGl6ZShpdGVtcywgcG9zdFtrZXldLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc3Rba2V5XSA9IHJlcztcbiAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgcG9zdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNhbml0aXphdGlvbiBDbGFzcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBpbmhlcml0cyBmcm9tIEluc3BlY3Rpb24gY2xhc3MgKGFjdHVhbGx5IHdlIGp1c3QgY2FsbCBJbnNwZWN0aW9uXG4gIC8vIGNvbnN0cnVjdG9yIHdpdGggdGhlIG5ldyBjb250ZXh0LCBiZWNhdXNlIGl0cyBwcm90b3R5cGUgaXMgZW1wdHlcbiAgZnVuY3Rpb24gU2FuaXRpemF0aW9uKHNjaGVtYSwgY3VzdG9tKSB7XG4gICAgSW5zcGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBzY2hlbWEsIF9tZXJnZShTYW5pdGl6YXRpb24uY3VzdG9tLCBjdXN0b20pKTtcbiAgICB2YXIgX3JlcG9ydGluZyA9IFtdO1xuXG4gICAgdGhpcy5fYmFzaWNGaWVsZHMgPSBPYmplY3Qua2V5cyhfc2FuaXRpemF0aW9uQXR0cmlidXQpO1xuICAgIHRoaXMuX2N1c3RvbUZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2N1c3RvbSk7XG4gICAgdGhpcy5vcmlnaW4gPSBudWxsO1xuXG4gICAgdGhpcy5yZXBvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgdmFyIG5ld05vdCA9IHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCAnd2FzIHNhbml0aXplZCcsXG4gICAgICAgIHByb3BlcnR5OiB0aGlzLnVzZXJBbGlhcyA/ICh0aGlzLnVzZXJBbGlhcyArICcgKCcgKyB0aGlzLl9kdW1wU3RhY2soKSArICcpJykgOiB0aGlzLl9kdW1wU3RhY2soKVxuICAgICAgfTtcbiAgICAgIGlmICghX3JlcG9ydGluZy5zb21lKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnByb3BlcnR5ID09PSBuZXdOb3QucHJvcGVydHk7IH0pKSB7XG4gICAgICAgIF9yZXBvcnRpbmcucHVzaChuZXdOb3QpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnJlc3VsdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAvLyBGb3Igb2xkIElFLlxuICAgICAgLyogZXNsaW50LWRpc2FibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgcmVwb3J0aW5nOiBfcmVwb3J0aW5nLFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXBvcnRpbmcubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1Byb3BlcnR5ICcgKyBpLnByb3BlcnR5ICsgJyAnICsgaS5tZXNzYWdlO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXG4gICAgfTtcbiAgfVxuXG4gIF9leHRlbmQoU2FuaXRpemF0aW9uLnByb3RvdHlwZSwgX3Nhbml0aXphdGlvbkF0dHJpYnV0KTtcbiAgX2V4dGVuZChTYW5pdGl6YXRpb24ucHJvdG90eXBlLCBfYXN5bmNTYW5pdGl6YXRpb25BdHRyaWJ1dCk7XG4gIF9leHRlbmQoU2FuaXRpemF0aW9uLCBuZXcgQ3VzdG9taXNhYmxlKCkpO1xuXG4gIFNhbml0aXphdGlvbi5wcm90b3R5cGUuc2FuaXRpemUgPSBmdW5jdGlvbiAocG9zdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLm9yaWdpbiA9IHBvc3Q7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jU2FuaXRpemUodGhpcy5fc2NoZW1hLCBwb3N0LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIHNlbGYub3JpZ2luID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyLCBzZWxmLnJlc3VsdChkYXRhKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9zYW5pdGl6ZSh0aGlzLl9zY2hlbWEsIHBvc3QpO1xuICAgIHRoaXMub3JpZ2luID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQoZGF0YSk7XG4gIH07XG5cbiAgU2FuaXRpemF0aW9uLnByb3RvdHlwZS5fc2FuaXRpemUgPSBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgdGhpcy51c2VyQWxpYXMgPSBzY2hlbWEuYWxpYXMgfHwgbnVsbDtcbiAgICB0aGlzLl9iYXNpY0ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoKGkgaW4gc2NoZW1hIHx8IGkgPT09ICdvcHRpb25hbCcpICYmIHR5cGVvZiB0aGlzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc3QgPSB0aGlzW2ldKHNjaGVtYSwgcG9zdCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fY3VzdG9tRmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIGlmIChpIGluIHNjaGVtYSAmJiB0eXBlb2YgdGhpcy5fY3VzdG9tW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc3QgPSB0aGlzLl9jdXN0b21baV0uY2FsbCh0aGlzLCBzY2hlbWEsIHBvc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBwb3N0O1xuICB9O1xuXG4gIFNhbml0aXphdGlvbi5wcm90b3R5cGUuX2FzeW5jU2FuaXRpemUgPSBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnVzZXJBbGlhcyA9IHNjaGVtYS5hbGlhcyB8fCBudWxsO1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIGFzeW5jLnJlZHVjZShzZWxmLl9iYXNpY0ZpZWxkcywgcG9zdCwgZnVuY3Rpb24gKHZhbHVlLCBpLCBuZXh0KSB7XG4gICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKChpIGluIHNjaGVtYSB8fCBpID09PSAnb3B0aW9uYWwnKSAmJiB0eXBlb2Ygc2VsZltpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAoc2VsZltpXS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZbaV0oc2NoZW1hLCB2YWx1ZSwgbmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmW2ldKHNjaGVtYSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dChudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIG5leHQpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChpbnRlciwgbmV4dCkge1xuICAgICAgICBhc3luYy5yZWR1Y2Uoc2VsZi5fY3VzdG9tRmllbGRzLCBpbnRlciwgZnVuY3Rpb24gKHZhbHVlLCBpLCBuZXh0KSB7XG4gICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2NoZW1hICYmIHR5cGVvZiBzZWxmLl9jdXN0b21baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuX2N1c3RvbVtpXS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2N1c3RvbVtpXS5jYWxsKHNlbGYsIHNjaGVtYSwgdmFsdWUsIG5leHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gc2VsZi5fY3VzdG9tW2ldLmNhbGwoc2VsZiwgc2NoZW1hLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0KG51bGwsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbmV4dCk7XG4gICAgICB9XG4gICAgXSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBJTlRfTUlOID0gLTIxNDc0ODM2NDg7XG4gIHZhciBJTlRfTUFYID0gMjE0NzQ4MzY0NztcblxuICB2YXIgX3JhbmQgPSB7XG4gICAgaW50OiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBtaW4gKyAoMCB8IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH0sXG4gICAgZmxvYXQ6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pO1xuICAgIH0sXG4gICAgYm9vbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpID4gMC41KTtcbiAgICB9LFxuICAgIGNoYXI6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5pbnQobWluLCBtYXgpKTtcbiAgICB9LFxuICAgIGZyb21MaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgcmV0dXJuIGxpc3RbdGhpcy5pbnQoMCwgbGlzdC5sZW5ndGggLSAxKV07XG4gICAgfVxuICB9O1xuXG4gIHZhciBfZm9ybWF0U2FtcGxlID0ge1xuICAgICdkYXRlLXRpbWUnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIH0sXG4gICAgZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9ULiokLywgJycpO1xuICAgIH0sXG4gICAgdGltZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKHt9LCB7IGhvdXIxMjogZmFsc2UgfSk7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICB2YXIgcyA9ICcjJztcbiAgICAgIGlmIChtaW4gPCAxKSB7XG4gICAgICAgIG1pbiA9IDE7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9yYW5kLmludChtaW4sIG1heCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcyArPSBfcmFuZC5mcm9tTGlzdCgnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcbiAgICBudW1lcmljOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJycgKyBfcmFuZC5pbnQoMCwgSU5UX01BWCk7XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3JhbmQuYm9vbCgpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAnLScgKyB0aGlzLm51bWVyaWMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm51bWVyaWMoKTtcbiAgICB9LFxuICAgIGRlY2ltYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVnZXIoKSArICcuJyArIHRoaXMubnVtZXJpYygpO1xuICAgIH0sXG4gICAgYWxwaGE6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIGlmIChtaW4gPCAxKSB7XG4gICAgICAgIG1pbiA9IDE7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9yYW5kLmludChtaW4sIG1heCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcyArPSBfcmFuZC5mcm9tTGlzdCgnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcbiAgICBhbHBoYU51bWVyaWM6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIGlmIChtaW4gPCAxKSB7XG4gICAgICAgIG1pbiA9IDE7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9yYW5kLmludChtaW4sIG1heCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcyArPSBfcmFuZC5mcm9tTGlzdCgnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH0sXG4gICAgYWxwaGFEYXNoOiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICBpZiAobWluIDwgMSkge1xuICAgICAgICBtaW4gPSAxO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfcmFuZC5pbnQobWluLCBtYXgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHMgKz0gX3JhbmQuZnJvbUxpc3QoJ18tYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpfLUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXy0wMTIzNDU2Nzg5Xy0nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH0sXG4gICAgamF2YXNjcmlwdDogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICB2YXIgcyA9IF9yYW5kLmZyb21MaXN0KCdfJGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XyRBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl8kJyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9yYW5kLmludChtaW4sIG1heCAtIDEpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHMgKz0gX3JhbmQuZnJvbUxpc3QoJ18kYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpfJEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXyQwMTIzNDU2Nzg5XyQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBfZ2V0TGltaXRzKHNjaGVtYSkge1xuICAgIHZhciBtaW4gPSBJTlRfTUlOO1xuICAgIHZhciBtYXggPSBJTlRfTUFYO1xuXG4gICAgaWYgKHNjaGVtYS5ndGUgIT0gbnVsbCkge1xuICAgICAgbWluID0gc2NoZW1hLmd0ZTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5ndCAhPSBudWxsKSB7XG4gICAgICBtaW4gPSBzY2hlbWEuZ3QgKyAxO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmx0ZSAhPSBudWxsKSB7XG4gICAgICBtYXggPSBzY2hlbWEubHRlO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hLmx0ICE9IG51bGwpIHtcbiAgICAgIG1heCA9IHNjaGVtYS5sdCAtIDE7XG4gICAgfVxuICAgIC8vIEZvciBvbGQgSUUuXG4gICAgLyogZXNsaW50LWRpc2FibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuICB9XG5cbiAgdmFyIF90eXBlR2VuZXJhdG9yID0ge1xuICAgIHN0cmluZzogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgaWYgKHNjaGVtYS5lcSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZXE7XG4gICAgICB9XG4gICAgICB2YXIgcyA9ICcnO1xuICAgICAgdmFyIG1pbkxlbmd0aCA9IHNjaGVtYS5taW5MZW5ndGggIT0gbnVsbCA/IHNjaGVtYS5taW5MZW5ndGggOiAwO1xuICAgICAgdmFyIG1heExlbmd0aCA9IHNjaGVtYS5tYXhMZW5ndGggIT0gbnVsbCA/IHNjaGVtYS5tYXhMZW5ndGggOiAzMjtcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnBhdHRlcm4gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBfZm9ybWF0U2FtcGxlW3NjaGVtYS5wYXR0ZXJuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gX2Zvcm1hdFNhbXBsZVtzY2hlbWEucGF0dGVybl0obWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbCA9IHNjaGVtYS5leGFjdExlbmd0aCAhPSBudWxsID8gc2NoZW1hLmV4YWN0TGVuZ3RoIDogX3JhbmQuaW50KG1pbkxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHMgKz0gX3JhbmQuY2hhcigzMiwgMTI2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICBpZiAoc2NoZW1hLmVxICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5lcTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW1pdCA9IF9nZXRMaW1pdHMoc2NoZW1hKTtcbiAgICAgIHZhciBuID0gX3JhbmQuZmxvYXQobGltaXQubWluLCBsaW1pdC5tYXgpO1xuICAgICAgaWYgKHNjaGVtYS5uZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuZSA9IF90eXBlSXMuYXJyYXkoc2NoZW1hLm5lKSA/IHNjaGVtYS5uZSA6IFtzY2hlbWEubmVdO1xuICAgICAgICB3aGlsZSAobmUuaW5kZXhPZihuKSAhPT0gLTEpIHtcbiAgICAgICAgICBuID0gX3JhbmQuZmxvYXQobGltaXQubWluLCBsaW1pdC5tYXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIGludGVnZXI6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIGlmIChzY2hlbWEuZXEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmVxO1xuICAgICAgfVxuICAgICAgdmFyIGxpbWl0ID0gX2dldExpbWl0cyhzY2hlbWEpO1xuICAgICAgdmFyIG4gPSBfcmFuZC5pbnQobGltaXQubWluLCBsaW1pdC5tYXgpO1xuICAgICAgaWYgKHNjaGVtYS5uZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuZSA9IF90eXBlSXMuYXJyYXkoc2NoZW1hLm5lKSA/IHNjaGVtYS5uZSA6IFtzY2hlbWEubmVdO1xuICAgICAgICB3aGlsZSAobmUuaW5kZXhPZihuKSAhPT0gLTEpIHtcbiAgICAgICAgICBuID0gX3JhbmQuaW50KGxpbWl0Lm1pbiwgbGltaXQubWF4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSxcbiAgICBib29sZWFuOiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICBpZiAoc2NoZW1hLmVxICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5lcTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmFuZC5ib29sKCk7XG4gICAgfSxcbiAgICBudWxsOiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGRhdGU6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIGlmIChzY2hlbWEuZXEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmVxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgfSxcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICB2YXIgcHJvcCA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3AsIGtleSkpIHtcbiAgICAgICAgICBpZiAocHJvcFtrZXldLm9wdGlvbmFsID09PSB0cnVlICYmIF9yYW5kLmJvb2woKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkgIT09ICcqJykge1xuICAgICAgICAgICAgb1trZXldID0gdGhpcy5nZW5lcmF0ZShwcm9wW2tleV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmsgPSAnX19yYW5kb21fa2V5Xyc7XG4gICAgICAgICAgICB2YXIgcmFuZG9tS2V5ID0gcmsgKyAwO1xuICAgICAgICAgICAgdmFyIG4gPSBfcmFuZC5pbnQoMSwgOSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCEocmFuZG9tS2V5IGluIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgb1tyYW5kb21LZXldID0gdGhpcy5nZW5lcmF0ZShwcm9wW2tleV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJhbmRvbUtleSA9IHJrICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG4gICAgYXJyYXk6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpdGVtcyA9IHNjaGVtYS5pdGVtcyB8fCB7fTtcbiAgICAgIHZhciBtaW5MZW5ndGggPSBzY2hlbWEubWluTGVuZ3RoICE9IG51bGwgPyBzY2hlbWEubWluTGVuZ3RoIDogMDtcbiAgICAgIHZhciBtYXhMZW5ndGggPSBzY2hlbWEubWF4TGVuZ3RoICE9IG51bGwgPyBzY2hlbWEubWF4TGVuZ3RoIDogMTY7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHZhciBjYW5kaWRhdGU7XG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShpdGVtcykpIHtcbiAgICAgICAgc2l6ZSA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVtYS5leGFjdExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc2l6ZSA9IHNjaGVtYS5leGFjdExlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgc2l6ZSA9IG1pbkxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgc2l6ZSA9IG1heExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGUgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgdHlwZSA9IGl0ZW1zW2ldLnR5cGUgfHwgJ2FueSc7XG4gICAgICAgICAgaWYgKF90eXBlSXMuYXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlW19yYW5kLmludCgwLCB0eXBlLmxlbmd0aCAtIDEpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FuZGlkYXRlW2ldID0gc2VsZlt0eXBlXShpdGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBzY2hlbWEuZXhhY3RMZW5ndGggIT0gbnVsbCA/IHNjaGVtYS5leGFjdExlbmd0aCA6IF9yYW5kLmludChtaW5MZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhbmRpZGF0ZSA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgdHlwZSA9IGl0ZW1zLnR5cGUgfHwgJ2FueSc7XG4gICAgICAgIGlmIChfdHlwZUlzLmFycmF5KHR5cGUpKSB7XG4gICAgICAgICAgdHlwZSA9IHR5cGVbX3JhbmQuaW50KDAsIHR5cGUubGVuZ3RoIC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBjYW5kaWRhdGVbaV0gPSBzZWxmW3R5cGVdKGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICB9LFxuICAgIGFueTogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKF90eXBlR2VuZXJhdG9yKTtcbiAgICAgIHZhciBpID0gZmllbGRzW19yYW5kLmludCgwLCBmaWVsZHMubGVuZ3RoIC0gMildO1xuICAgICAgcmV0dXJuIHRoaXNbaV0oc2NoZW1hKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FuZGlkYXRlR2VuZXJhdG9yIENsYXNzIChTaW5nbGV0b24pIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIENhbmRpZGF0ZUdlbmVyYXRvcigpIHtcbiAgICAvLyBNYXliZSBleHRlbmRzIEluc3BlY3Rpb24gY2xhc3MgdG9vID9cbiAgfVxuXG4gIF9leHRlbmQoQ2FuZGlkYXRlR2VuZXJhdG9yLnByb3RvdHlwZSwgX3R5cGVHZW5lcmF0b3IpO1xuXG4gIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuICBDYW5kaWRhdGVHZW5lcmF0b3IuaW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCEoX2luc3RhbmNlIGluc3RhbmNlb2YgQ2FuZGlkYXRlR2VuZXJhdG9yKSkge1xuICAgICAgX2luc3RhbmNlID0gbmV3IENhbmRpZGF0ZUdlbmVyYXRvcigpO1xuICAgIH1cbiAgICByZXR1cm4gX2luc3RhbmNlO1xuICB9O1xuXG4gIENhbmRpZGF0ZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgdmFyIHR5cGUgPSBzY2hlbWEudHlwZSB8fCAnYW55JztcbiAgICBpZiAoX3R5cGVJcy5hcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IHR5cGVbX3JhbmQuaW50KDAsIHR5cGUubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1t0eXBlXShzY2hlbWEpO1xuICB9O1xuXG4gIC8vIEV4cG9ydHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBTY2hlbWFJbnNwZWN0b3IgPSB7fTtcblxuICAvLyBpZiBzZXJ2ZXItc2lkZSAobm9kZS5qcykgZWxzZSBjbGllbnQtc2lkZVxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUluc3BlY3RvcjtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuU2NoZW1hSW5zcGVjdG9yID0gU2NoZW1hSW5zcGVjdG9yO1xuICB9XG5cbiAgU2NoZW1hSW5zcGVjdG9yLm5ld1Nhbml0aXphdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGN1c3RvbSkge1xuICAgIHJldHVybiBuZXcgU2FuaXRpemF0aW9uKHNjaGVtYSwgY3VzdG9tKTtcbiAgfTtcblxuICBTY2hlbWFJbnNwZWN0b3IubmV3VmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGN1c3RvbSkge1xuICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbihzY2hlbWEsIGN1c3RvbSk7XG4gIH07XG5cbiAgU2NoZW1hSW5zcGVjdG9yLlZhbGlkYXRpb24gPSBWYWxpZGF0aW9uO1xuICBTY2hlbWFJbnNwZWN0b3IuU2FuaXRpemF0aW9uID0gU2FuaXRpemF0aW9uO1xuXG4gIFNjaGVtYUluc3BlY3Rvci5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGN1c3RvbSwgY2FsbGJhY2spIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgY3VzdG9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGN1c3RvbTtcbiAgICAgIGN1c3RvbSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2FuaXRpemF0aW9uKHNjaGVtYSwgY3VzdG9tKS5zYW5pdGl6ZShwb3N0LCBjYWxsYmFjayk7XG4gIH07XG5cbiAgU2NoZW1hSW5zcGVjdG9yLnZhbGlkYXRlID0gZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjdXN0b20sIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGN1c3RvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBjdXN0b207XG4gICAgICBjdXN0b20gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhbGlkYXRpb24oc2NoZW1hLCBjdXN0b20pLnZhbGlkYXRlKGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIFNjaGVtYUluc3BlY3Rvci5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIG4pIHtcbiAgICBpZiAodHlwZW9mIG4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgciA9IG5ldyBBcnJheShuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHJbaV0gPSBDYW5kaWRhdGVHZW5lcmF0b3IuaW5zdGFuY2UoKS5nZW5lcmF0ZShzY2hlbWEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHJldHVybiBDYW5kaWRhdGVHZW5lcmF0b3IuaW5zdGFuY2UoKS5nZW5lcmF0ZShzY2hlbWEpO1xuICB9O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js\n");

/***/ })

};
;